From b5817ae78878078304b2099bd0e91b6bfac2ac58 Mon Sep 17 00:00:00 2001
From: Oleksandr Natalenko <oleksandr@natalenko.name>
Date: Sat, 23 Jan 2021 14:18:12 +0100
Subject: [PATCH 13/16] ntfs3-5.10: update to v18

Signed-off-by: Oleksandr Natalenko <oleksandr@natalenko.name>
---
 fs/ntfs3/Kconfig    |   8 +-
 fs/ntfs3/attrib.c   |  52 +++--
 fs/ntfs3/attrlist.c | 126 +++++-----
 fs/ntfs3/bitmap.c   |  14 +-
 fs/ntfs3/debug.h    |   3 +-
 fs/ntfs3/dir.c      |  29 ++-
 fs/ntfs3/file.c     |  12 +-
 fs/ntfs3/frecord.c  |  51 ++---
 fs/ntfs3/fslog.c    | 116 ++++------
 fs/ntfs3/fsntfs.c   |  38 ++--
 fs/ntfs3/index.c    | 138 ++++++-----
 fs/ntfs3/inode.c    |  11 +-
 fs/ntfs3/lznt.c     |   4 +-
 fs/ntfs3/ntfs.h     |   1 +
 fs/ntfs3/ntfs_fs.h  |  19 +-
 fs/ntfs3/record.c   |  61 +++--
 fs/ntfs3/run.c      | 542 +++++++++++++++++---------------------------
 fs/ntfs3/super.c    |  12 +-
 fs/ntfs3/upcase.c   |  83 ++++---
 fs/ntfs3/xattr.c    |   6 +-
 20 files changed, 615 insertions(+), 711 deletions(-)

diff --git a/fs/ntfs3/Kconfig b/fs/ntfs3/Kconfig
index f9b732f4a..e47a90567 100644
--- a/fs/ntfs3/Kconfig
+++ b/fs/ntfs3/Kconfig
@@ -27,8 +27,9 @@ config NTFS3_LZX_XPRESS
 	depends on NTFS3_FS
 	help
 	  In Windows 10 one can use command "compact" to compress any files.
-	  4 possible variants of compression are: xpress4k, xpress8k, xpress16 and lzx.
-	  To read such "compacted" files say Y here.
+	  4 possible variants of compression are: xpress4k, xpress8k, xpress16k and lzx.
+
+	  It is recommended to say Y here.
 
 config NTFS3_POSIX_ACL
 	bool "NTFS POSIX Access Control Lists"
@@ -39,3 +40,6 @@ config NTFS3_POSIX_ACL
 	  for users and groups beyond the standard owner/group/world scheme,
 	  and this option selects support for ACLs specifically for ntfs
 	  filesystems.
+	  NOTE: this is linux only feature. Windows will ignore these ACLs.
+
+	  If you don't know what Access Control Lists are, say N
diff --git a/fs/ntfs3/attrib.c b/fs/ntfs3/attrib.c
index 0e2c98e31..79360d944 100644
--- a/fs/ntfs3/attrib.c
+++ b/fs/ntfs3/attrib.c
@@ -129,7 +129,7 @@ static int run_deallocate_ex(struct ntfs_sb_info *sbi, struct runs_tree *run,
 			     CLST vcn, CLST len, CLST *done, bool trim)
 {
 	int err = 0;
-	CLST vcn0 = vcn, lcn, clen, dn = 0;
+	CLST vcn_next, vcn0 = vcn, lcn, clen, dn = 0;
 	size_t idx;
 
 	if (!len)
@@ -160,7 +160,9 @@ static int run_deallocate_ex(struct ntfs_sb_info *sbi, struct runs_tree *run,
 		if (!len)
 			break;
 
-		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen)) {
+		vcn_next = vcn + clen;
+		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
+		    vcn != vcn_next) {
 			// save memory - don't load entire run
 			goto failed;
 		}
@@ -1179,12 +1181,12 @@ int attr_load_runs_vcn(struct ntfs_inode *ni, enum ATTR_TYPE type,
 	return 0;
 }
 
-#ifdef CONFIG_NTFS3_LZX_XPRESS
 /*
  * load runs for given range [from to)
  */
-int attr_wof_load_runs_range(struct ntfs_inode *ni, struct runs_tree *run,
-			     u64 from, u64 to)
+int attr_load_runs_range(struct ntfs_inode *ni, enum ATTR_TYPE type,
+			 const __le16 *name, u8 name_len, struct runs_tree *run,
+			 u64 from, u64 to)
 {
 	struct ntfs_sb_info *sbi = ni->mi.sbi;
 	u8 cluster_bits = sbi->cluster_bits;
@@ -1195,8 +1197,7 @@ int attr_wof_load_runs_range(struct ntfs_inode *ni, struct runs_tree *run,
 
 	for (vcn = from >> cluster_bits; vcn <= vcn_last; vcn += clen) {
 		if (!run_lookup_entry(run, vcn, &lcn, &clen, NULL)) {
-			err = attr_load_runs_vcn(ni, ATTR_DATA, WOF_NAME,
-						 ARRAY_SIZE(WOF_NAME), run,
+			err = attr_load_runs_vcn(ni, type, name, name_len, run,
 						 vcn);
 			if (err)
 				return err;
@@ -1207,6 +1208,7 @@ int attr_wof_load_runs_range(struct ntfs_inode *ni, struct runs_tree *run,
 	return 0;
 }
 
+#ifdef CONFIG_NTFS3_LZX_XPRESS
 /*
  * attr_wof_frame_info
  *
@@ -1297,7 +1299,9 @@ int attr_wof_frame_info(struct ntfs_inode *ni, struct ATTRIB *attr,
 			u64 from = vbo[i] & ~(u64)(PAGE_SIZE - 1);
 			u64 to = min(from + PAGE_SIZE, wof_size);
 
-			err = attr_wof_load_runs_range(ni, run, from, to);
+			err = attr_load_runs_range(ni, ATTR_DATA, WOF_NAME,
+						   ARRAY_SIZE(WOF_NAME), run,
+						   from, to);
 			if (err)
 				goto out1;
 
@@ -1362,7 +1366,7 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 {
 	int err;
 	u32 clst_frame;
-	CLST len, lcn, vcn, alen, slen, vcn1;
+	CLST clen, lcn, vcn, alen, slen, vcn_next;
 	size_t idx;
 	struct runs_tree *run;
 
@@ -1378,14 +1382,14 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 	vcn = frame * clst_frame;
 	run = &ni->file.run;
 
-	if (!run_lookup_entry(run, vcn, &lcn, &len, &idx)) {
+	if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {
 		err = attr_load_runs_vcn(ni, attr->type, attr_name(attr),
 					 attr->name_len, run, vcn);
 		if (err)
 			return err;
 
-		if (!run_lookup_entry(run, vcn, &lcn, &len, &idx))
-			return -ENOENT;
+		if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx))
+			return -EINVAL;
 	}
 
 	if (lcn == SPARSE_LCN) {
@@ -1393,7 +1397,7 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 		return 0;
 	}
 
-	if (len >= clst_frame) {
+	if (clen >= clst_frame) {
 		/*
 		 * The frame is not compressed 'cause
 		 * it does not contain any sparse clusters
@@ -1404,30 +1408,30 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 
 	alen = bytes_to_cluster(ni->mi.sbi, le64_to_cpu(attr->nres.alloc_size));
 	slen = 0;
-	*clst_data = len;
+	*clst_data = clen;
 
 	/*
 	 * The frame is compressed if *clst_data + slen >= clst_frame
 	 * Check next fragments
 	 */
-	while ((vcn += len) < alen) {
-		vcn1 = vcn;
+	while ((vcn += clen) < alen) {
+		vcn_next = vcn;
 
-		if (!run_get_entry(run, ++idx, &vcn, &lcn, &len) ||
-		    vcn1 != vcn) {
+		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
+		    vcn_next != vcn) {
 			err = attr_load_runs_vcn(ni, attr->type,
 						 attr_name(attr),
-						 attr->name_len, run, vcn1);
+						 attr->name_len, run, vcn_next);
 			if (err)
 				return err;
-			vcn = vcn1;
+			vcn = vcn_next;
 
-			if (!run_lookup_entry(run, vcn, &lcn, &len, &idx))
-				return -ENOENT;
+			if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx))
+				return -EINVAL;
 		}
 
 		if (lcn == SPARSE_LCN) {
-			slen += len;
+			slen += clen;
 		} else {
 			if (slen) {
 				/*
@@ -1436,7 +1440,7 @@ int attr_is_frame_compressed(struct ntfs_inode *ni, struct ATTRIB *attr,
 				 */
 				return -EINVAL;
 			}
-			*clst_data += len;
+			*clst_data += clen;
 		}
 
 		if (*clst_data + slen >= clst_frame) {
diff --git a/fs/ntfs3/attrlist.c b/fs/ntfs3/attrlist.c
index e94512259..4a97e259d 100644
--- a/fs/ntfs3/attrlist.c
+++ b/fs/ntfs3/attrlist.c
@@ -51,7 +51,7 @@ int ntfs_load_attr_list(struct ntfs_inode *ni, struct ATTRIB *attr)
 
 	if (!attr->non_res) {
 		lsize = le32_to_cpu(attr->res.data_size);
-		le = ntfs_alloc(al_aligned(lsize), 0);
+		le = ntfs_malloc(al_aligned(lsize));
 		if (!le) {
 			err = -ENOMEM;
 			goto out;
@@ -74,7 +74,7 @@ int ntfs_load_attr_list(struct ntfs_inode *ni, struct ATTRIB *attr)
 		if (err < 0)
 			goto out;
 
-		le = ntfs_alloc(al_aligned(lsize), 0);
+		le = ntfs_malloc(al_aligned(lsize));
 		if (!le) {
 			err = -ENOMEM;
 			goto out;
@@ -172,10 +172,9 @@ struct ATTR_LIST_ENTRY *al_find_ex(struct ntfs_inode *ni,
 
 	while ((le = al_enumerate(ni, le))) {
 		u64 le_vcn;
-		int diff;
+		int diff = le32_to_cpu(le->type) - type_in;
 
 		/* List entries are sorted by type, name and vcn */
-		diff = le32_to_cpu(le->type) - type_in;
 		if (diff < 0)
 			continue;
 
@@ -185,14 +184,24 @@ struct ATTR_LIST_ENTRY *al_find_ex(struct ntfs_inode *ni,
 		if (le->name_len != name_len)
 			continue;
 
-		if (name_len &&
-		    memcmp(le_name(le), name, name_len * sizeof(short)))
-			continue;
+		le_vcn = le64_to_cpu(le->vcn);
+		if (!le_vcn) {
+			/*
+			 * compare entry names only for entry with vcn == 0
+			 */
+			diff = ntfs_cmp_names(le_name(le), name_len, name,
+					      name_len, ni->mi.sbi->upcase,
+					      true);
+			if (diff < 0)
+				continue;
+
+			if (diff > 0)
+				return ret;
+		}
 
 		if (!vcn)
 			return le;
 
-		le_vcn = le64_to_cpu(le->vcn);
 		if (*vcn == le_vcn)
 			return le;
 
@@ -209,39 +218,44 @@ struct ATTR_LIST_ENTRY *al_find_ex(struct ntfs_inode *ni,
  * al_find_le_to_insert
  *
  * finds the first list entry which matches type, name and vcn
- * Returns NULL if not found
  */
-static struct ATTR_LIST_ENTRY *
-al_find_le_to_insert(struct ntfs_inode *ni, enum ATTR_TYPE type,
-		     const __le16 *name, u8 name_len, const CLST *vcn)
+static struct ATTR_LIST_ENTRY *al_find_le_to_insert(struct ntfs_inode *ni,
+						    enum ATTR_TYPE type,
+						    const __le16 *name,
+						    u8 name_len, CLST vcn)
 {
 	struct ATTR_LIST_ENTRY *le = NULL, *prev;
 	u32 type_in = le32_to_cpu(type);
-	int diff;
 
 	/* List entries are sorted by type, name, vcn */
-next:
-	le = al_enumerate(ni, prev = le);
-	if (!le)
-		goto out;
-	diff = le32_to_cpu(le->type) - type_in;
-	if (diff < 0)
-		goto next;
-	if (diff > 0)
-		goto out;
+	while ((le = al_enumerate(ni, prev = le))) {
+		int diff = le32_to_cpu(le->type) - type_in;
 
-	if (ntfs_cmp_names(name, name_len, le_name(le), le->name_len, NULL) > 0)
-		goto next;
+		if (diff < 0)
+			continue;
 
-	if (!vcn || *vcn > le64_to_cpu(le->vcn))
-		goto next;
+		if (diff > 0)
+			return le;
 
-out:
-	if (!le)
-		le = prev ? Add2Ptr(prev, le16_to_cpu(prev->size)) :
-			    ni->attr_list.le;
+		if (!le->vcn) {
+			/*
+			 * compare entry names only for entry with vcn == 0
+			 */
+			diff = ntfs_cmp_names(le_name(le), le->name_len, name,
+					      name_len, ni->mi.sbi->upcase,
+					      true);
+			if (diff < 0)
+				continue;
+
+			if (diff > 0)
+				return le;
+		}
 
-	return le;
+		if (le64_to_cpu(le->vcn) >= vcn)
+			return le;
+	}
+
+	return prev ? Add2Ptr(prev, le16_to_cpu(prev->size)) : ni->attr_list.le;
 }
 
 /*
@@ -272,11 +286,11 @@ int al_add_le(struct ntfs_inode *ni, enum ATTR_TYPE type, const __le16 *name,
 	new_asize = al_aligned(new_size);
 
 	/* Scan forward to the point at which the new le should be inserted. */
-	le = al_find_le_to_insert(ni, type, name, name_len, &svcn);
+	le = al_find_le_to_insert(ni, type, name, name_len, svcn);
 	off = PtrOffset(al->le, le);
 
 	if (new_size > asize) {
-		void *ptr = ntfs_alloc(new_asize, 0);
+		void *ptr = ntfs_malloc(new_asize);
 
 		if (!ptr)
 			return -ENOMEM;
@@ -368,50 +382,30 @@ bool al_delete_le(struct ntfs_inode *ni, enum ATTR_TYPE type, CLST vcn,
 
 	off = PtrOffset(al->le, le);
 
-	if (!ref)
-		goto del;
-
-	/*
-	 * The caller specified a segment reference, so we have to
-	 * scan through the matching entries until we find that segment
-	 * reference or we run of matching entries.
-	 */
 next:
-	if (off + sizeof(struct ATTR_LIST_ENTRY) > al->size)
-		goto del;
-	if (le->type != type)
-		goto del;
-	if (le->name_len != name_len)
-		goto del;
-	if (name_len &&
-	    memcmp(name, Add2Ptr(le, le->name_off), name_len * sizeof(short)))
-		goto del;
-	if (le64_to_cpu(le->vcn) != vcn)
-		goto del;
-	if (!memcmp(ref, &le->ref, sizeof(*ref)))
-		goto del;
-
-	off += le16_to_cpu(le->size);
-	le = Add2Ptr(al->le, off);
-	goto next;
-
-del:
-	/*
-	 * If we've gone off the end of the list, or if the type, name,
-	 * and vcn don't match, then we don't have any matching records.
-	 */
 	if (off >= al->size)
 		return false;
 	if (le->type != type)
 		return false;
 	if (le->name_len != name_len)
 		return false;
-	if (name_len &&
-	    memcmp(name, Add2Ptr(le, le->name_off), name_len * sizeof(short)))
+	if (name_len && ntfs_cmp_names(le_name(le), name_len, name, name_len,
+				       ni->mi.sbi->upcase, true))
 		return false;
 	if (le64_to_cpu(le->vcn) != vcn)
 		return false;
 
+	/*
+	 * The caller specified a segment reference, so we have to
+	 * scan through the matching entries until we find that segment
+	 * reference or we run of matching entries.
+	 */
+	if (ref && memcmp(ref, &le->ref, sizeof(*ref))) {
+		off += le16_to_cpu(le->size);
+		le = Add2Ptr(al->le, off);
+		goto next;
+	}
+
 	/* Save on stack the size of le */
 	size = le16_to_cpu(le->size);
 	/* Delete the le. */
diff --git a/fs/ntfs3/bitmap.c b/fs/ntfs3/bitmap.c
index db7c4567c..1a4d65a6a 100644
--- a/fs/ntfs3/bitmap.c
+++ b/fs/ntfs3/bitmap.c
@@ -326,7 +326,7 @@ static void wnd_add_free_ext(struct wnd_bitmap *wnd, size_t bit, size_t len,
 		rb_erase(&e->count.node, &wnd->count_tree);
 		wnd->count -= 1;
 	} else {
-		e = e0 ? e0 : ntfs_alloc(sizeof(struct e_node), 0);
+		e = e0 ? e0 : ntfs_malloc(sizeof(struct e_node));
 		if (!e) {
 			wnd->uptodated = -1;
 			goto out;
@@ -466,7 +466,7 @@ static void wnd_remove_free_ext(struct wnd_bitmap *wnd, size_t bit, size_t len)
 		rb_erase(&e->count.node, &wnd->count_tree);
 		wnd->count -= 1;
 	} else {
-		e = ntfs_alloc(sizeof(struct e_node), 0);
+		e = ntfs_malloc(sizeof(struct e_node));
 		if (!e)
 			wnd->uptodated = -1;
 	}
@@ -536,14 +536,16 @@ static int wnd_rescan(struct wnd_bitmap *wnd)
 		}
 
 		if (!len) {
+			u32 off = vbo & sbi->cluster_mask;
+
 			if (!run_lookup_entry(&wnd->run, vbo >> cluster_bits,
 					      &lcn, &clen, NULL)) {
 				err = -ENOENT;
 				goto out;
 			}
 
-			lbo = (u64)lcn << cluster_bits;
-			len = (u64)clen << cluster_bits;
+			lbo = ((u64)lcn << cluster_bits) + off;
+			len = ((u64)clen << cluster_bits) - off;
 		}
 
 		bh = ntfs_bread(sb, lbo >> sb->s_blocksize_bits);
@@ -661,7 +663,7 @@ int wnd_init(struct wnd_bitmap *wnd, struct super_block *sb, size_t nbits)
 	if (wnd->nwnd <= ARRAY_SIZE(wnd->free_holder)) {
 		wnd->free_bits = wnd->free_holder;
 	} else {
-		wnd->free_bits = ntfs_alloc(wnd->nwnd * sizeof(u16), 1);
+		wnd->free_bits = ntfs_zalloc(wnd->nwnd * sizeof(u16));
 		if (!wnd->free_bits)
 			return -ENOMEM;
 	}
@@ -1336,7 +1338,7 @@ int wnd_extend(struct wnd_bitmap *wnd, size_t new_bits)
 		if (new_wnd <= ARRAY_SIZE(wnd->free_holder)) {
 			new_free = wnd->free_holder;
 		} else {
-			new_free = ntfs_alloc(new_wnd * sizeof(u16), 0);
+			new_free = ntfs_malloc(new_wnd * sizeof(u16));
 			if (!new_free)
 				return -ENOMEM;
 		}
diff --git a/fs/ntfs3/debug.h b/fs/ntfs3/debug.h
index 9e57ef878..418934210 100644
--- a/fs/ntfs3/debug.h
+++ b/fs/ntfs3/debug.h
@@ -55,7 +55,8 @@ void ntfs_inode_printk(struct inode *inode, const char *fmt, ...)
 #define ntfs_inode_warn(inode, fmt, ...)                                       \
 	ntfs_inode_printk(inode, KERN_WARNING fmt, ##__VA_ARGS__)
 
-#define ntfs_alloc(s, z)	kmalloc(s, (z) ? (GFP_NOFS | __GFP_ZERO) : GFP_NOFS)
+#define ntfs_malloc(s)		kmalloc(s, GFP_NOFS)
+#define ntfs_zalloc(s)		kzalloc(s, GFP_NOFS)
 #define ntfs_free(p)		kfree(p)
 #define ntfs_memdup(src, len)	kmemdup(src, len, GFP_NOFS)
 // clang-format on
diff --git a/fs/ntfs3/dir.c b/fs/ntfs3/dir.c
index df2de511e..eaf3cea33 100644
--- a/fs/ntfs3/dir.c
+++ b/fs/ntfs3/dir.c
@@ -75,13 +75,14 @@ int ntfs_utf16_to_nls(struct ntfs_sb_info *sbi, const struct le_str *uni,
 #define SURROGATE_PAIR	0x0000d800
 #define SURROGATE_LOW	0x00000400
 #define SURROGATE_BITS	0x000003ff
-// clang-format off
+// clang-format on
 
 /*
  * modified version of put_utf16 from fs/nls/nls_base.c
  * is sparse warnings free
  */
-static inline void put_utf16(wchar_t *s, unsigned int c, enum utf16_endian endian)
+static inline void put_utf16(wchar_t *s, unsigned int c,
+			     enum utf16_endian endian)
 {
 	static_assert(sizeof(wchar_t) == sizeof(__le16));
 	static_assert(sizeof(wchar_t) == sizeof(__be16));
@@ -178,8 +179,7 @@ int ntfs_nls_to_utf16(struct ntfs_sb_info *sbi, const u8 *name, u32 name_len,
 
 	if (!nls) {
 		/* utf8 -> utf16 */
-		ret = _utf8s_to_utf16s(name, name_len, endian, uname,
-					max_ulen);
+		ret = _utf8s_to_utf16s(name, name_len, endian, uname, max_ulen);
 		uni->len = ret;
 		return ret;
 	}
@@ -387,7 +387,22 @@ static int ntfs_readdir(struct file *file, struct dir_context *ctx)
 	if (!name)
 		return -ENOMEM;
 
-	ni_lock(ni);
+	if (!ni->mi_loaded && ni->attr_list.size) {
+		/*
+		 * directory inode is locked for read
+		 * load all subrecords to avoid 'write' access to 'ni' during
+		 * directory reading
+		 */
+		ni_lock(ni);
+		if (!ni->mi_loaded && ni->attr_list.size) {
+			err = ni_load_all_mi(ni);
+			if (!err)
+				ni->mi_loaded = true;
+		}
+		ni_unlock(ni);
+		if (err)
+			goto out;
+	}
 
 	root = indx_get_root(&ni->dir, ni, NULL, NULL);
 	if (!root) {
@@ -455,8 +470,6 @@ static int ntfs_readdir(struct file *file, struct dir_context *ctx)
 		ctx->pos = pos;
 	}
 
-	ni_unlock(ni);
-
 	return err;
 }
 
@@ -565,6 +578,6 @@ const struct file_operations ntfs_dir_operations = {
 	.llseek = generic_file_llseek,
 	.read = generic_read_dir,
 	.iterate_shared = ntfs_readdir,
-	.fsync = ntfs_file_fsync,
+	.fsync = generic_file_fsync,
 	.open = ntfs_file_open,
 };
diff --git a/fs/ntfs3/file.c b/fs/ntfs3/file.c
index a65ca1673..bac5a10ac 100644
--- a/fs/ntfs3/file.c
+++ b/fs/ntfs3/file.c
@@ -342,14 +342,6 @@ static int ntfs_file_mmap(struct file *file, struct vm_area_struct *vma)
 	return err;
 }
 
-/*
- * file_operations::fsync
- */
-int ntfs_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)
-{
-	return generic_file_fsync(filp, start, end, datasync);
-}
-
 static int ntfs_extend(struct inode *inode, loff_t pos, size_t count,
 		       struct file *file)
 {
@@ -790,7 +782,7 @@ static ssize_t ntfs_compress_write(struct kiocb *iocb, struct iov_iter *from)
 		return -EOPNOTSUPP;
 	}
 
-	pages = ntfs_alloc(pages_per_frame * sizeof(struct page *), 0);
+	pages = ntfs_malloc(pages_per_frame * sizeof(struct page *));
 	if (!pages)
 		return -ENOMEM;
 
@@ -1133,7 +1125,7 @@ const struct file_operations ntfs_file_operations = {
 	.splice_read = generic_file_splice_read,
 	.mmap = ntfs_file_mmap,
 	.open = ntfs_file_open,
-	.fsync = ntfs_file_fsync,
+	.fsync = generic_file_fsync,
 	.splice_write = iter_file_splice_write,
 	.fallocate = ntfs_fallocate,
 	.release = ntfs_file_release,
diff --git a/fs/ntfs3/frecord.c b/fs/ntfs3/frecord.c
index 0f6cb42ce..3e436dd75 100644
--- a/fs/ntfs3/frecord.c
+++ b/fs/ntfs3/frecord.c
@@ -400,7 +400,7 @@ bool ni_add_subrecord(struct ntfs_inode *ni, CLST rno, struct mft_inode **mi)
 {
 	struct mft_inode *m;
 
-	m = ntfs_alloc(sizeof(struct mft_inode), 1);
+	m = ntfs_zalloc(sizeof(struct mft_inode));
 	if (!m)
 		return false;
 
@@ -799,7 +799,7 @@ int ni_create_attr_list(struct ntfs_inode *ni)
 	 * Skip estimating exact memory requirement
 	 * Looks like one record_size is always enough
 	 */
-	le = ntfs_alloc(al_aligned(rs), 0);
+	le = ntfs_malloc(al_aligned(rs));
 	if (!le) {
 		err = -ENOMEM;
 		goto out;
@@ -1634,7 +1634,8 @@ struct ATTR_FILE_NAME *ni_fname_name(struct ntfs_inode *ni,
 	if (uni->len != fname->name_len)
 		goto next;
 
-	if (ntfs_cmp_names_cpu(uni, (struct le_str *)&fname->name_len, NULL))
+	if (ntfs_cmp_names_cpu(uni, (struct le_str *)&fname->name_len, NULL,
+			       false))
 		goto next;
 
 	return fname;
@@ -1873,7 +1874,7 @@ int ni_fiemap(struct ntfs_inode *ni, struct fiemap_extent_info *fieinfo,
 		run = &ni->dir.alloc_run;
 		attr = ni_find_attr(ni, NULL, NULL, ATTR_ALLOC, I30_NAME,
 				    ARRAY_SIZE(I30_NAME), NULL, NULL);
-		run_lock = NULL;
+		run_lock = &ni->dir.run_lock;
 	} else {
 		run = &ni->file.run;
 		attr = ni_find_attr(ni, NULL, NULL, ATTR_DATA, NULL, 0, NULL,
@@ -1907,36 +1908,30 @@ int ni_fiemap(struct ntfs_inode *ni, struct fiemap_extent_info *fieinfo,
 	if (end > alloc_size)
 		end = alloc_size;
 
-	if (run_lock)
-		down_read(run_lock);
+	down_read(run_lock);
 
 	while (vbo < end) {
 		if (idx == -1) {
 			ok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);
 		} else {
-			CLST next_vcn = vcn;
+			CLST vcn_next = vcn;
 
-			ok = run_get_entry(run, ++idx, &vcn, &lcn, &clen);
-			if (ok && vcn != next_vcn) {
-				ok = false;
-				vcn = next_vcn;
-			}
+			ok = run_get_entry(run, ++idx, &vcn, &lcn, &clen) &&
+			     vcn == vcn_next;
+			if (!ok)
+				vcn = vcn_next;
 		}
 
 		if (!ok) {
-			if (run_lock) {
-				up_read(run_lock);
-				down_write(run_lock);
-			}
+			up_read(run_lock);
+			down_write(run_lock);
 
 			err = attr_load_runs_vcn(ni, attr->type,
 						 attr_name(attr),
 						 attr->name_len, run, vcn);
 
-			if (run_lock) {
-				up_write(run_lock);
-				down_read(run_lock);
-			}
+			up_write(run_lock);
+			down_read(run_lock);
 
 			if (err)
 				break;
@@ -2024,8 +2019,7 @@ int ni_fiemap(struct ntfs_inode *ni, struct fiemap_extent_info *fieinfo,
 		vbo += bytes;
 	}
 
-	if (run_lock)
-		up_read(run_lock);
+	up_read(run_lock);
 
 out:
 	return err;
@@ -2068,7 +2062,7 @@ int ni_readpage_cmpr(struct ntfs_inode *ni, struct page *page)
 	idx = (vbo - frame_vbo) >> PAGE_SHIFT;
 
 	pages_per_frame = frame_size >> PAGE_SHIFT;
-	pages = ntfs_alloc(pages_per_frame * sizeof(struct page *), 1);
+	pages = ntfs_zalloc(pages_per_frame * sizeof(struct page *));
 	if (!pages) {
 		err = -ENOMEM;
 		goto out;
@@ -2151,7 +2145,7 @@ int ni_decompress_file(struct ntfs_inode *ni)
 	frame_bits = ni_ext_compress_bits(ni);
 	frame_size = 1u << frame_bits;
 	pages_per_frame = frame_size >> PAGE_SHIFT;
-	pages = ntfs_alloc(pages_per_frame * sizeof(struct page *), 1);
+	pages = ntfs_zalloc(pages_per_frame * sizeof(struct page *));
 	if (!pages) {
 		err = -ENOMEM;
 		goto out;
@@ -2524,8 +2518,9 @@ int ni_read_frame(struct ntfs_inode *ni, u64 frame_vbo, struct page **pages,
 		}
 		vbo_disk = vbo_data;
 		/* load all runs to read [vbo_disk-vbo_to) */
-		err = attr_wof_load_runs_range(ni, run, vbo_disk,
-					       vbo_data + ondisk_size);
+		err = attr_load_runs_range(ni, ATTR_DATA, WOF_NAME,
+					   ARRAY_SIZE(WOF_NAME), run, vbo_disk,
+					   vbo_data + ondisk_size);
 		if (err)
 			goto out2;
 		npages_disk = (ondisk_size + (vbo_disk & (PAGE_SIZE - 1)) +
@@ -2577,7 +2572,7 @@ int ni_read_frame(struct ntfs_inode *ni, u64 frame_vbo, struct page **pages,
 		goto out1;
 	}
 
-	pages_disk = ntfs_alloc(npages_disk * sizeof(struct page *), 1);
+	pages_disk = ntfs_zalloc(npages_disk * sizeof(struct page *));
 	if (!pages_disk) {
 		err = -ENOMEM;
 		goto out2;
@@ -2722,7 +2717,7 @@ int ni_write_frame(struct ntfs_inode *ni, struct page **pages,
 		goto out;
 	}
 
-	pages_disk = ntfs_alloc(pages_per_frame * sizeof(struct page *), 1);
+	pages_disk = ntfs_zalloc(pages_per_frame * sizeof(struct page *));
 	if (!pages_disk) {
 		err = -ENOMEM;
 		goto out;
diff --git a/fs/ntfs3/fslog.c b/fs/ntfs3/fslog.c
index 14162b03d..1aeaa2544 100644
--- a/fs/ntfs3/fslog.c
+++ b/fs/ntfs3/fslog.c
@@ -808,7 +808,7 @@ static inline struct RESTART_TABLE *init_rsttbl(u16 esize, u16 used)
 	u32 off;
 	u32 bytes = esize * used + sizeof(struct RESTART_TABLE);
 	u32 lf = sizeof(struct RESTART_TABLE) + (used - 1) * esize;
-	struct RESTART_TABLE *t = ntfs_alloc(bytes, 1);
+	struct RESTART_TABLE *t = ntfs_zalloc(bytes);
 
 	t->size = cpu_to_le16(esize);
 	t->used = cpu_to_le16(used);
@@ -1119,8 +1119,7 @@ struct restart_info {
 };
 
 static int read_log_page(struct ntfs_log *log, u32 vbo,
-			 struct RECORD_PAGE_HDR **buffer, bool allow_errors,
-			 bool ignore_usa_error, bool *usa_error)
+			 struct RECORD_PAGE_HDR **buffer, bool *usa_error)
 {
 	int err = 0;
 	u32 page_idx = vbo >> log->page_bits;
@@ -1136,7 +1135,7 @@ static int read_log_page(struct ntfs_log *log, u32 vbo,
 		return -EINVAL;
 
 	if (!*buffer) {
-		to_free = ntfs_alloc(bytes, 0);
+		to_free = ntfs_malloc(bytes);
 		if (!to_free)
 			return -ENOMEM;
 		*buffer = to_free;
@@ -1157,17 +1156,12 @@ static int read_log_page(struct ntfs_log *log, u32 vbo,
 
 	bBAAD = page_buf->rhdr.sign == NTFS_BAAD_SIGNATURE;
 
-	/* Check that the update sequence array for this page is valid */
-	if (bBAAD) {
-		/* If we don't allow errors, raise an error status */
-		if (!ignore_usa_error) {
-			err = -EINVAL;
-			goto out;
-		}
-	}
-
 	if (usa_error)
 		*usa_error = bBAAD;
+	/* Check that the update sequence array for this page is valid */
+	/* If we don't allow errors, raise an error status */
+	else if (bBAAD)
+		err = -EINVAL;
 
 out:
 	if (err && to_free) {
@@ -1187,9 +1181,8 @@ static int read_log_page(struct ntfs_log *log, u32 vbo,
 static int log_read_rst(struct ntfs_log *log, u32 l_size, bool first,
 			struct restart_info *info)
 {
-	int err;
 	u32 skip, vbo;
-	struct RESTART_HDR *r_page = ntfs_alloc(DefaultLogPageSize, 0);
+	struct RESTART_HDR *r_page = ntfs_malloc(DefaultLogPageSize);
 
 	if (!r_page)
 		return -ENOMEM;
@@ -1213,12 +1206,11 @@ static int log_read_rst(struct ntfs_log *log, u32 l_size, bool first,
 		struct RESTART_AREA *ra;
 
 		/* Read a page header at the current offset */
-		err = read_log_page(log, vbo,
-				    (struct RECORD_PAGE_HDR **)&r_page, true,
-				    true, &usa_error);
-
-		if (err)
+		if (read_log_page(log, vbo, (struct RECORD_PAGE_HDR **)&r_page,
+				  &usa_error)) {
+			/* ignore any errors */
 			continue;
+		}
 
 		/* exit if the signature is a log record page */
 		if (r_page->rhdr.sign == NTFS_RCRD_SIGNATURE) {
@@ -1267,17 +1259,17 @@ static int log_read_rst(struct ntfs_log *log, u32 l_size, bool first,
 		sys_page_size = le32_to_cpu(r_page->sys_page_size);
 		if (DefaultLogPageSize != sys_page_size) {
 			ntfs_free(r_page);
-			r_page = ntfs_alloc(sys_page_size, 1);
+			r_page = ntfs_zalloc(sys_page_size);
 			if (!r_page)
 				return -ENOMEM;
 
-			err = read_log_page(log, vbo,
-					    (struct RECORD_PAGE_HDR **)&r_page,
-					    true, true, &usa_error);
-
-			if (err) {
+			if (read_log_page(log, vbo,
+					  (struct RECORD_PAGE_HDR **)&r_page,
+					  &usa_error)) {
+				/* ignore any errors */
 				ntfs_free(r_page);
-				return err;
+				r_page = NULL;
+				continue;
 			}
 		}
 
@@ -1407,7 +1399,7 @@ static void log_create(struct ntfs_log *log, u32 l_size, const u64 last_lsn,
 static struct RESTART_AREA *log_create_ra(struct ntfs_log *log)
 {
 	struct CLIENT_REC *cr;
-	struct RESTART_AREA *ra = ntfs_alloc(log->restart_size, 1);
+	struct RESTART_AREA *ra = ntfs_zalloc(log->restart_size);
 
 	if (!ra)
 		return NULL;
@@ -1488,7 +1480,7 @@ static int next_log_lsn(struct ntfs_log *log, const struct LFS_RECORD_HDR *rh,
 		seq += 1;
 
 	/* log page header for this page */
-	err = read_log_page(log, hdr_off, &page, false, false, NULL);
+	err = read_log_page(log, hdr_off, &page, NULL);
 	if (err)
 		return err;
 
@@ -1644,7 +1636,7 @@ static int last_log_lsn(struct ntfs_log *log)
 		second_off = 0x12 * log->page_size;
 
 		// 0x10 == 0x12 - 0x2
-		page_bufs = ntfs_alloc(log->page_size * 0x10, 0);
+		page_bufs = ntfs_malloc(log->page_size * 0x10);
 		if (!page_bufs)
 			return -ENOMEM;
 	} else {
@@ -1654,8 +1646,7 @@ static int last_log_lsn(struct ntfs_log *log)
 
 next_tail:
 	/* Read second tail page (at pos 3/0x12000) */
-	if (read_log_page(log, second_off, &second_tail, true, true,
-			  &usa_error) ||
+	if (read_log_page(log, second_off, &second_tail, &usa_error) ||
 	    usa_error || second_tail->rhdr.sign != NTFS_RCRD_SIGNATURE) {
 		ntfs_free(second_tail);
 		second_tail = NULL;
@@ -1667,8 +1658,7 @@ static int last_log_lsn(struct ntfs_log *log)
 	}
 
 	/* Read first tail page (at pos 2/0x2000 ) */
-	if (read_log_page(log, final_off, &first_tail, true, true,
-			  &usa_error) ||
+	if (read_log_page(log, final_off, &first_tail, &usa_error) ||
 	    usa_error || first_tail->rhdr.sign != NTFS_RCRD_SIGNATURE) {
 		ntfs_free(first_tail);
 		first_tail = NULL;
@@ -1726,7 +1716,7 @@ static int last_log_lsn(struct ntfs_log *log)
 		best_page = second_tail;
 		this_off = second_file_off;
 	} else {
-		goto free_and_tail_read;
+		goto tail_read;
 	}
 
 	best_page_pos = le16_to_cpu(best_page->page_pos);
@@ -1771,7 +1761,6 @@ static int last_log_lsn(struct ntfs_log *log)
 			page_pos = page_cnt = 1;
 		}
 	} else {
-free_and_tail_read:
 		ntfs_free(first_tail);
 		ntfs_free(second_tail);
 		goto tail_read;
@@ -1814,8 +1803,8 @@ static int last_log_lsn(struct ntfs_log *log)
 
 next_page:
 	tail_page = NULL;
-	/* Read the next log page, allowing errors */
-	err = read_log_page(log, curpage_off, &page, true, true, &usa_error);
+	/* Read the next log page */
+	err = read_log_page(log, curpage_off, &page, &usa_error);
 
 	/* Compute the next log page offset the file */
 	nextpage_off = next_page_off(log, curpage_off);
@@ -2109,7 +2098,7 @@ static int last_log_lsn(struct ntfs_log *log)
 	tst_page = NULL;
 
 	/* Walk through the file, reading log pages */
-	err = read_log_page(log, nextpage_off, &tst_page, 1, 1, &usa_error);
+	err = read_log_page(log, nextpage_off, &tst_page, &usa_error);
 
 	/*
 	 * If we get a USA error then assume that we correctly found
@@ -2167,8 +2156,7 @@ static int last_log_lsn(struct ntfs_log *log)
 	ntfs_free(tst_page);
 	tst_page = NULL;
 
-	err = read_log_page(log, nextpage_off, &tst_page, true, true,
-			    &usa_error);
+	err = read_log_page(log, nextpage_off, &tst_page, &usa_error);
 	if (!err && !usa_error &&
 	    check_subseq_log_page(log, tst_page, nextpage_off, expected_seq)) {
 		err = -EINVAL;
@@ -2200,7 +2188,7 @@ static int last_log_lsn(struct ntfs_log *log)
 			u64 off = hdr_file_off(log, tmp_page);
 
 			if (!page) {
-				page = ntfs_alloc(log->page_size, 0);
+				page = ntfs_malloc(log->page_size);
 				if (!page)
 					return -ENOMEM;
 			}
@@ -2275,6 +2263,7 @@ static int read_log_rec_buf(struct ntfs_log *log,
 	 * we continue to attempt to perform the read
 	 */
 	for (;;) {
+		bool usa_error;
 		u32 tail = log->page_size - off;
 
 		if (tail >= data_len)
@@ -2282,7 +2271,7 @@ static int read_log_rec_buf(struct ntfs_log *log,
 
 		data_len -= tail;
 
-		err = read_log_page(log, vbo, &ph, false, true, NULL);
+		err = read_log_page(log, vbo, &ph, &usa_error);
 		if (err)
 			goto out;
 
@@ -2347,7 +2336,7 @@ static int read_rst_area(struct ntfs_log *log, struct NTFS_RESTART **rst_,
 		return 0;
 
 	err = read_log_page(log, lsn_to_vbo(log, lsnc),
-			    (struct RECORD_PAGE_HDR **)&rh, false, false, NULL);
+			    (struct RECORD_PAGE_HDR **)&rh, NULL);
 	if (err)
 		return err;
 
@@ -2373,7 +2362,7 @@ static int read_rst_area(struct ntfs_log *log, struct NTFS_RESTART **rst_,
 		goto out;
 	}
 
-	rst = ntfs_alloc(len, 0);
+	rst = ntfs_malloc(len);
 	if (!rst) {
 		err = -ENOMEM;
 		goto out;
@@ -2403,8 +2392,7 @@ static int find_log_rec(struct ntfs_log *log, u64 lsn, struct lcb *lcb)
 	/* Read the record header for this lsn */
 	if (!rh) {
 		err = read_log_page(log, lsn_to_vbo(log, lsn),
-				    (struct RECORD_PAGE_HDR **)&rh, false,
-				    false, NULL);
+				    (struct RECORD_PAGE_HDR **)&rh, NULL);
 
 		lcb->lrh = rh;
 		if (err)
@@ -2433,7 +2421,7 @@ static int find_log_rec(struct ntfs_log *log, u64 lsn, struct lcb *lcb)
 	 * put a pointer to the log record the context block
 	 */
 	if (rh->flags & LOG_RECORD_MULTI_PAGE) {
-		void *lr = ntfs_alloc(len, 0);
+		void *lr = ntfs_malloc(len);
 
 		if (!lr)
 			return -ENOMEM;
@@ -2486,7 +2474,7 @@ static int read_log_rec_lcb(struct ntfs_log *log, u64 lsn, u32 ctx_mode,
 	if (!verify_client_lsn(log, cr, lsn))
 		return -EINVAL;
 
-	lcb = ntfs_alloc(sizeof(struct lcb), 1);
+	lcb = ntfs_zalloc(sizeof(struct lcb));
 	if (!lcb)
 		return -ENOMEM;
 	lcb->client = log->client_id;
@@ -2539,8 +2527,7 @@ static int find_client_next_lsn(struct ntfs_log *log, struct lcb *lcb, u64 *lsn)
 
 		hdr = NULL;
 		err = read_log_page(log, lsn_to_vbo(log, current_lsn),
-				    (struct RECORD_PAGE_HDR **)&hdr, false,
-				    false, NULL);
+				    (struct RECORD_PAGE_HDR **)&hdr, NULL);
 		if (err)
 			goto out;
 
@@ -2578,8 +2565,7 @@ static int find_client_next_lsn(struct ntfs_log *log, struct lcb *lcb, u64 *lsn)
 
 	hdr = NULL;
 	err = read_log_page(log, lsn_to_vbo(log, next_lsn),
-			    (struct RECORD_PAGE_HDR **)&hdr, false, false,
-			    NULL);
+			    (struct RECORD_PAGE_HDR **)&hdr, NULL);
 	if (err)
 		return err;
 	ntfs_free(lcb->lrh);
@@ -3004,7 +2990,7 @@ static struct ATTRIB *attr_create_nonres_log(struct ntfs_sb_info *sbi,
 	u32 asize = name_size +
 		    (is_ext ? SIZEOF_NONRESIDENT_EX : SIZEOF_NONRESIDENT);
 
-	attr = ntfs_alloc(asize, 1);
+	attr = ntfs_zalloc(asize);
 	if (!attr)
 		return NULL;
 
@@ -3103,7 +3089,7 @@ static int do_action(struct ntfs_log *log, struct OPEN_ATTR_ENRTY *oe,
 		if (inode) {
 			mi = &ntfs_i(inode)->mi;
 		} else if (op == InitializeFileRecordSegment) {
-			mi = ntfs_alloc(sizeof(struct mft_inode), 1);
+			mi = ntfs_zalloc(sizeof(struct mft_inode));
 			if (!mi)
 				return -ENOMEM;
 			err = mi_format_new(mi, sbi, rno, 0, false);
@@ -3198,7 +3184,7 @@ static int do_action(struct ntfs_log *log, struct OPEN_ATTR_ENRTY *oe,
 		if (attr->type == ATTR_ALLOC)
 			bytes = (bytes + 511) & ~511; // align
 
-		buffer_le = ntfs_alloc(bytes, 0);
+		buffer_le = ntfs_malloc(bytes);
 		if (!buffer_le)
 			return -ENOMEM;
 
@@ -3824,13 +3810,13 @@ int log_replay(struct ntfs_inode *ni)
 	if (!page_size)
 		return -EINVAL;
 
-	log = ntfs_alloc(sizeof(struct ntfs_log), 1);
+	log = ntfs_zalloc(sizeof(struct ntfs_log));
 	if (!log)
 		return -ENOMEM;
 
 	log->ni = ni;
 	log->l_size = l_size;
-	log->one_page_buf = ntfs_alloc(page_size, 0);
+	log->one_page_buf = ntfs_malloc(page_size);
 
 	if (!log->one_page_buf) {
 		err = -ENOMEM;
@@ -3886,8 +3872,9 @@ int log_replay(struct ntfs_inode *ni)
 
 	if (rst_info.chkdsk_was_run && page_size != rst_info.vbo) {
 		struct RECORD_PAGE_HDR *sp = NULL;
+		bool usa_error;
 
-		if (!read_log_page(log, page_size, &sp, true, true, NULL) &&
+		if (!read_log_page(log, page_size, &sp, &usa_error) &&
 		    sp->rhdr.sign == NTFS_CHKD_SIGNATURE) {
 			use_second_page = false;
 		}
@@ -4049,7 +4036,7 @@ int log_replay(struct ntfs_inode *ni)
 
 	log->current_avail = current_log_avail(log);
 
-	ra = ntfs_alloc(log->restart_size, 1);
+	ra = ntfs_zalloc(log->restart_size);
 	if (!ra) {
 		err = -ENOMEM;
 		goto out;
@@ -4077,9 +4064,6 @@ int log_replay(struct ntfs_inode *ni)
 
 	/* Now we need to walk through looking for the last lsn */
 	err = last_log_lsn(log);
-	if (err == -EROFS)
-		goto out;
-
 	if (err)
 		goto out;
 
@@ -4616,7 +4600,7 @@ int log_replay(struct ntfs_inode *ni)
 
 		t16 = le16_to_cpu(lrh->undo_len);
 		if (t16) {
-			oe->ptr = ntfs_alloc(t16, 0);
+			oe->ptr = ntfs_malloc(t16);
 			if (!oe->ptr) {
 				err = -ENOMEM;
 				goto out;
@@ -4721,7 +4705,7 @@ int log_replay(struct ntfs_inode *ni)
 		goto next_dirty_page;
 	}
 
-	oa = ntfs_alloc(sizeof(struct OpenAttr), 1);
+	oa = ntfs_zalloc(sizeof(struct OpenAttr));
 	if (!oa) {
 		err = -ENOMEM;
 		goto out;
@@ -5128,7 +5112,7 @@ int log_replay(struct ntfs_inode *ni)
 	if (is_ro)
 		goto out;
 
-	rh = ntfs_alloc(log->page_size, 1);
+	rh = ntfs_zalloc(log->page_size);
 	if (!rh) {
 		err = -ENOMEM;
 		goto out;
diff --git a/fs/ntfs3/fsntfs.c b/fs/ntfs3/fsntfs.c
index eb972616c..a552add30 100644
--- a/fs/ntfs3/fsntfs.c
+++ b/fs/ntfs3/fsntfs.c
@@ -307,7 +307,6 @@ int ntfs_loadlog_and_replay(struct ntfs_inode *ni, struct ntfs_sb_info *sbi)
 	sync_blockdev(sb->s_bdev);
 	invalidate_bdev(sb->s_bdev);
 
-	/* reinit MFT */
 	if (sbi->flags & NTFS_FLAGS_NEED_REPLAY) {
 		err = 0;
 		goto out;
@@ -1108,11 +1107,11 @@ int ntfs_sb_write_run(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 	struct super_block *sb = sbi->sb;
 	u8 cluster_bits = sbi->cluster_bits;
 	u32 off = vbo & sbi->cluster_mask;
-	CLST lcn, clen;
+	CLST lcn, clen, vcn = vbo >> cluster_bits, vcn_next;
 	u64 lbo, len;
 	size_t idx;
 
-	if (!run_lookup_entry(run, vbo >> cluster_bits, &lcn, &clen, &idx))
+	if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx))
 		return -ENOENT;
 
 	if (lcn == SPARSE_LCN)
@@ -1132,7 +1131,9 @@ int ntfs_sb_write_run(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 		if (!bytes)
 			break;
 
-		if (!run_get_entry(run, ++idx, NULL, &lcn, &clen))
+		vcn_next = vcn + clen;
+		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
+		    vcn != vcn_next)
 			return -ENOENT;
 
 		if (lcn == SPARSE_LCN)
@@ -1141,8 +1142,8 @@ int ntfs_sb_write_run(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 		if (buf)
 			buf = Add2Ptr(buf, op);
 
-		lbo = ((u64)lcn << cluster_bits) + off;
-		len = ((u64)clen << cluster_bits) - off;
+		lbo = ((u64)lcn << cluster_bits);
+		len = ((u64)clen << cluster_bits);
 	}
 
 	return 0;
@@ -1173,6 +1174,7 @@ int ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 	u8 cluster_bits = sbi->cluster_bits;
 	u32 off = vbo & sbi->cluster_mask;
 	u32 nbh = 0;
+	CLST vcn_next, vcn = vbo >> cluster_bits;
 	CLST lcn, clen;
 	u64 lbo, len;
 	size_t idx;
@@ -1188,8 +1190,7 @@ int ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 		/* use absolute boot's 'MFTCluster' to read record */
 		lbo = vbo + sbi->mft.lbo;
 		len = sbi->record_size;
-	} else if (!run_lookup_entry(run, vbo >> cluster_bits, &lcn, &clen,
-				     &idx)) {
+	} else if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {
 		err = -ENOENT;
 		goto out;
 	} else {
@@ -1248,7 +1249,9 @@ int ntfs_read_run_nb(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 
 		} while (len32);
 
-		if (!run_get_entry(run, ++idx, NULL, &lcn, &clen)) {
+		vcn_next = vcn + clen;
+		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
+		    vcn != vcn_next) {
 			err = -ENOENT;
 			goto out;
 		}
@@ -1294,6 +1297,7 @@ int ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,
 	struct super_block *sb = sbi->sb;
 	u32 blocksize = sb->s_blocksize;
 	u8 cluster_bits = sbi->cluster_bits;
+	CLST vcn_next, vcn = vbo >> cluster_bits;
 	u32 off;
 	u32 nbh = 0;
 	CLST lcn, clen;
@@ -1302,7 +1306,7 @@ int ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,
 
 	nb->bytes = bytes;
 
-	if (!run_lookup_entry(run, vbo >> cluster_bits, &lcn, &clen, &idx)) {
+	if (!run_lookup_entry(run, vcn, &lcn, &clen, &idx)) {
 		err = -ENOENT;
 		goto out;
 	}
@@ -1359,7 +1363,9 @@ int ntfs_get_bh(struct ntfs_sb_info *sbi, const struct runs_tree *run, u64 vbo,
 			off = 0;
 		} while (len32);
 
-		if (!run_get_entry(run, ++idx, NULL, &lcn, &clen)) {
+		vcn_next = vcn + clen;
+		if (!run_get_entry(run, ++idx, &vcn, &lcn, &clen) ||
+		    vcn != vcn_next) {
 			err = -ENOENT;
 			goto out;
 		}
@@ -1480,7 +1486,7 @@ int ntfs_bio_pages(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 	struct block_device *bdev = sb->s_bdev;
 	struct page *page;
 	u8 cluster_bits = sbi->cluster_bits;
-	CLST lcn, clen, vcn;
+	CLST lcn, clen, vcn, vcn_next;
 	u32 add, off, page_idx;
 	u64 lbo, len;
 	size_t run_idx;
@@ -1550,7 +1556,9 @@ int ntfs_bio_pages(struct ntfs_sb_info *sbi, const struct runs_tree *run,
 			lbo += add;
 		}
 
-		if (!run_get_entry(run, ++run_idx, &vcn, &lcn, &clen)) {
+		vcn_next = vcn + clen;
+		if (!run_get_entry(run, ++run_idx, &vcn, &lcn, &clen) ||
+		    vcn != vcn_next) {
 			err = -ENOENT;
 			goto out;
 		}
@@ -2014,7 +2022,7 @@ int ntfs_get_security_by_id(struct ntfs_sb_info *sbi, __le32 security_id,
 
 	*size = t32 - SIZEOF_SECURITY_HDR;
 
-	p = ntfs_alloc(*size, 0);
+	p = ntfs_malloc(*size);
 	if (!p) {
 		err = -ENOMEM;
 		goto out;
@@ -2094,7 +2102,7 @@ int ntfs_insert_security(struct ntfs_sb_info *sbi,
 	*security_id = SECURITY_ID_INVALID;
 
 	/* Allocate a temporal buffer*/
-	d_security = ntfs_alloc(aligned_sec_size, 1);
+	d_security = ntfs_zalloc(aligned_sec_size);
 	if (!d_security)
 		return -ENOMEM;
 
diff --git a/fs/ntfs3/index.c b/fs/ntfs3/index.c
index dfcdef0f7..772692282 100644
--- a/fs/ntfs3/index.c
+++ b/fs/ntfs3/index.c
@@ -34,8 +34,8 @@ static int cmp_fnames(const struct ATTR_FILE_NAME *f1, size_t l1,
 		      const struct ATTR_FILE_NAME *f2, size_t l2,
 		      const struct ntfs_sb_info *sbi)
 {
-	int diff;
 	u16 fsize2;
+	bool both_case;
 
 	if (l2 <= offsetof(struct ATTR_FILE_NAME, name))
 		return -1;
@@ -44,40 +44,20 @@ static int cmp_fnames(const struct ATTR_FILE_NAME *f1, size_t l1,
 	if (l2 < fsize2)
 		return -1;
 
+	both_case = f2->type != FILE_NAME_DOS /*&& !sbi->options.nocase*/;
 	if (!l1) {
 		const struct cpu_str *s1 = (struct cpu_str *)f1;
 		const struct le_str *s2 = (struct le_str *)&f2->name_len;
 
-		diff = ntfs_cmp_names_cpu(s1, s2, sbi->upcase);
-
-		if (diff)
-			return diff;
-
 		/*
 		 * If names are equal (case insensitive)
 		 * try to compare it case sensitive
 		 */
-		if (/*sbi->options.nocase || */ f2->type == FILE_NAME_DOS)
-			return 0;
-
-		return ntfs_cmp_names_cpu(s1, s2, NULL);
+		return ntfs_cmp_names_cpu(s1, s2, sbi->upcase, both_case);
 	}
 
-	diff = ntfs_cmp_names(f1->name, f1->name_len, f2->name, f2->name_len,
-			      sbi->upcase);
-
-	if (diff)
-		return diff;
-
-	/*
-	 * If names are equal (case insensitive)
-	 * try to compare it case sensitive
-	 */
-	if (/*sbi->options.nocase || */ f2->type == FILE_NAME_DOS)
-		return 0;
-
 	return ntfs_cmp_names(f1->name, f1->name_len, f2->name, f2->name_len,
-			      NULL);
+			      sbi->upcase, both_case);
 }
 
 /* $SII of $Secure and $Q of Quota */
@@ -356,13 +336,21 @@ static int indx_mark_free(struct ntfs_index *indx, struct ntfs_inode *ni,
 	return 0;
 }
 
-static int scan_nres_bitmap(struct ntfs_sb_info *sbi, struct ATTRIB *bitmap,
-			    struct runs_tree *run, size_t from,
+/*
+ * if ntfs_readdir calls this function (indx_used_bit -> scan_nres_bitmap),
+ * inode is shared locked and no ni_lock
+ * use rw_semaphore for read/write access to bitmap_run
+ */
+static int scan_nres_bitmap(struct ntfs_inode *ni, struct ATTRIB *bitmap,
+			    struct ntfs_index *indx, size_t from,
 			    bool (*fn)(const ulong *buf, u32 bit, u32 bits,
 				       size_t *ret),
 			    size_t *ret)
 {
+	struct ntfs_sb_info *sbi = ni->mi.sbi;
 	struct super_block *sb = sbi->sb;
+	struct runs_tree *run = &indx->bitmap_run;
+	struct rw_semaphore *lock = &indx->run_lock;
 	u32 nbits = sb->s_blocksize * 8;
 	u32 blocksize = sb->s_blocksize;
 	u64 valid_size = le64_to_cpu(bitmap->nres.valid_size);
@@ -372,9 +360,10 @@ static int scan_nres_bitmap(struct ntfs_sb_info *sbi, struct ATTRIB *bitmap,
 	sector_t blk = (vbo & sbi->cluster_mask) >> sb->s_blocksize_bits;
 	sector_t vblock = vbo >> sb->s_blocksize_bits;
 	sector_t blen, block;
-	CLST lcn, len;
+	CLST lcn, clen, vcn, vcn_next;
 	size_t idx;
 	struct buffer_head *bh;
+	bool ok;
 
 	*ret = MINUS_ONE_T;
 
@@ -382,19 +371,34 @@ static int scan_nres_bitmap(struct ntfs_sb_info *sbi, struct ATTRIB *bitmap,
 		return 0;
 
 	from &= nbits - 1;
+	vcn = vbo >> sbi->cluster_bits;
 
-	if (!run_lookup_entry(run, vbo >> sbi->cluster_bits, &lcn, &len,
-			      &idx)) {
-		return -ENOENT;
+	down_read(lock);
+	ok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);
+	up_read(lock);
+
+next_run:
+	if (!ok) {
+		int err;
+		const struct INDEX_NAMES *name = &s_index_names[indx->type];
+
+		down_write(lock);
+		err = attr_load_runs_vcn(ni, ATTR_BITMAP, name->name,
+					 name->name_len, run, vcn);
+		up_write(lock);
+		if (err)
+			return err;
+		down_read(lock);
+		ok = run_lookup_entry(run, vcn, &lcn, &clen, &idx);
+		up_read(lock);
+		if (!ok)
+			return -EINVAL;
 	}
 
-	blen = (sector_t)len * sbi->blocks_per_cluster;
+	blen = (sector_t)clen * sbi->blocks_per_cluster;
 	block = (sector_t)lcn * sbi->blocks_per_cluster;
 
-next_run:
 	for (; blk < blen; blk++, from = 0) {
-		bool ok;
-
 		bh = ntfs_bread(sb, block + blk);
 		if (!bh)
 			return -EIO;
@@ -426,13 +430,13 @@ static int scan_nres_bitmap(struct ntfs_sb_info *sbi, struct ATTRIB *bitmap,
 			return 0;
 		}
 	}
-
-	if (!run_get_entry(run, ++idx, NULL, &lcn, &len))
-		return -ENOENT;
-
 	blk = 0;
-	blen = (sector_t)len * sbi->blocks_per_cluster;
-	block = (sector_t)lcn * sbi->blocks_per_cluster;
+	vcn_next = vcn + clen;
+	down_read(lock);
+	ok = run_get_entry(run, ++idx, &vcn, &lcn, &clen) && vcn == vcn_next;
+	if (!ok)
+		vcn = vcn_next;
+	up_read(lock);
 	goto next_run;
 }
 
@@ -458,6 +462,7 @@ static int indx_find_free(struct ntfs_index *indx, struct ntfs_inode *ni,
 	struct ATTRIB *b;
 	struct ATTR_LIST_ENTRY *le = NULL;
 	const struct INDEX_NAMES *in = &s_index_names[indx->type];
+	int err;
 
 	b = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,
 			 NULL, NULL);
@@ -475,8 +480,7 @@ static int indx_find_free(struct ntfs_index *indx, struct ntfs_inode *ni,
 		if (pos < nbits)
 			*bit = pos;
 	} else {
-		int err = scan_nres_bitmap(ni->mi.sbi, b, &indx->bitmap_run, 0,
-					   &scan_for_free, bit);
+		err = scan_nres_bitmap(ni, b, indx, 0, &scan_for_free, bit);
 
 		if (err)
 			return err;
@@ -507,6 +511,7 @@ int indx_used_bit(struct ntfs_index *indx, struct ntfs_inode *ni, size_t *bit)
 	struct ATTR_LIST_ENTRY *le = NULL;
 	size_t from = *bit;
 	const struct INDEX_NAMES *in = &s_index_names[indx->type];
+	int err;
 
 	b = ni_find_attr(ni, NULL, &le, ATTR_BITMAP, in->name, in->name_len,
 			 NULL, NULL);
@@ -523,8 +528,7 @@ int indx_used_bit(struct ntfs_index *indx, struct ntfs_inode *ni, size_t *bit)
 		if (pos < nbits)
 			*bit = pos;
 	} else {
-		int err = scan_nres_bitmap(ni->mi.sbi, b, &indx->bitmap_run,
-					   from, &scan_for_used, bit);
+		err = scan_nres_bitmap(ni, b, indx, from, &scan_for_used, bit);
 		if (err)
 			return err;
 	}
@@ -643,7 +647,7 @@ static bool fnd_is_empty(struct ntfs_fnd *fnd)
 
 struct ntfs_fnd *fnd_get(struct ntfs_index *indx)
 {
-	struct ntfs_fnd *fnd = ntfs_alloc(sizeof(struct ntfs_fnd), 1);
+	struct ntfs_fnd *fnd = ntfs_zalloc(sizeof(struct ntfs_fnd));
 
 	if (!fnd)
 		return NULL;
@@ -687,7 +691,7 @@ static struct NTFS_DE *hdr_find_e(const struct ntfs_index *indx,
 	if (end > 0x10000)
 		goto next;
 
-	offs = ntfs_alloc(sizeof(u16) * nslots, 0);
+	offs = ntfs_malloc(sizeof(u16) * nslots);
 	if (!offs)
 		goto next;
 
@@ -709,7 +713,7 @@ static struct NTFS_DE *hdr_find_e(const struct ntfs_index *indx,
 		u16 *ptr;
 		int new_slots = QuadAlign(2 * nslots);
 
-		ptr = ntfs_alloc(sizeof(u16) * new_slots, 0);
+		ptr = ntfs_malloc(sizeof(u16) * new_slots);
 		if (ptr)
 			memcpy(ptr, offs, sizeof(u16) * max_idx);
 		ntfs_free(offs);
@@ -938,11 +942,11 @@ static struct indx_node *indx_new(struct ntfs_index *indx,
 	u16 fn;
 	u32 eo;
 
-	r = ntfs_alloc(sizeof(struct indx_node), 1);
+	r = ntfs_zalloc(sizeof(struct indx_node));
 	if (!r)
 		return ERR_PTR(-ENOMEM);
 
-	index = ntfs_alloc(bytes, 1);
+	index = ntfs_zalloc(bytes);
 	if (!index) {
 		ntfs_free(r);
 		return ERR_PTR(-ENOMEM);
@@ -1013,18 +1017,25 @@ static int indx_write(struct ntfs_index *indx, struct ntfs_inode *ni,
 	return ntfs_write_bh(ni->mi.sbi, &ib->rhdr, &node->nb, sync);
 }
 
+/*
+ * if ntfs_readdir calls this function
+ * inode is shared locked and no ni_lock
+ * use rw_semaphore for read/write access to alloc_run
+ */
 int indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,
 	      struct indx_node **node)
 {
 	int err;
 	struct INDEX_BUFFER *ib;
+	struct runs_tree *run = &indx->alloc_run;
+	struct rw_semaphore *lock = &indx->run_lock;
 	u64 vbo = (u64)vbn << indx->vbn2vbo_bits;
 	u32 bytes = 1u << indx->index_bits;
 	struct indx_node *in = *node;
 	const struct INDEX_NAMES *name;
 
 	if (!in) {
-		in = ntfs_alloc(sizeof(struct indx_node), 1);
+		in = ntfs_zalloc(sizeof(struct indx_node));
 		if (!in)
 			return -ENOMEM;
 	} else {
@@ -1033,16 +1044,16 @@ int indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,
 
 	ib = in->index;
 	if (!ib) {
-		ib = ntfs_alloc(bytes, 0);
+		ib = ntfs_malloc(bytes);
 		if (!ib) {
 			err = -ENOMEM;
 			goto out;
 		}
 	}
 
-	err = ntfs_read_bh(ni->mi.sbi, &indx->alloc_run, vbo, &ib->rhdr, bytes,
-			   &in->nb);
-
+	down_read(lock);
+	err = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);
+	up_read(lock);
 	if (!err)
 		goto ok;
 
@@ -1053,14 +1064,16 @@ int indx_read(struct ntfs_index *indx, struct ntfs_inode *ni, CLST vbn,
 		goto out;
 
 	name = &s_index_names[indx->type];
-	err = attr_load_runs_vcn(ni, ATTR_ALLOC, name->name, name->name_len,
-				 &indx->alloc_run,
-				 vbo >> ni->mi.sbi->cluster_bits);
+	down_write(lock);
+	err = attr_load_runs_range(ni, ATTR_ALLOC, name->name, name->name_len,
+				   run, vbo, vbo + bytes);
+	up_write(lock);
 	if (err)
 		goto out;
 
-	err = ntfs_read_bh(ni->mi.sbi, &indx->alloc_run, vbo, &ib->rhdr, bytes,
-			   &in->nb);
+	down_read(lock);
+	err = ntfs_read_bh(ni->mi.sbi, run, vbo, &ib->rhdr, bytes, &in->nb);
+	up_read(lock);
 	if (err == -E_NTFS_FIXUP)
 		goto ok;
 
@@ -1804,7 +1817,7 @@ indx_insert_into_buffer(struct ntfs_index *indx, struct ntfs_inode *ni,
 		return -EINVAL;
 
 	sp_size = le16_to_cpu(sp->size);
-	up_e = ntfs_alloc(sp_size + sizeof(u64), 0);
+	up_e = ntfs_malloc(sp_size + sizeof(u64));
 	if (!up_e)
 		return -ENOMEM;
 	memcpy(up_e, sp, sp_size);
@@ -2041,8 +2054,7 @@ static int indx_shrink(struct ntfs_index *indx, struct ntfs_inode *ni,
 		if (bit >= nbits)
 			return 0;
 
-		err = scan_nres_bitmap(ni->mi.sbi, b, &indx->bitmap_run, bit,
-				       &scan_for_used, &used);
+		err = scan_nres_bitmap(ni, b, indx, bit, &scan_for_used, &used);
 		if (err)
 			return err;
 
@@ -2166,7 +2178,7 @@ static int indx_get_entry_to_replace(struct ntfs_index *indx,
 	n = fnd->nodes[level];
 	te = hdr_first_de(&n->index->ihdr);
 	/* Copy the candidate entry into the replacement entry buffer. */
-	re = ntfs_alloc(le16_to_cpu(te->size) + sizeof(u64), 0);
+	re = ntfs_malloc(le16_to_cpu(te->size) + sizeof(u64));
 	if (!re) {
 		err = -ENOMEM;
 		goto out;
diff --git a/fs/ntfs3/inode.c b/fs/ntfs3/inode.c
index c74cb12dc..cbc674dc5 100644
--- a/fs/ntfs3/inode.c
+++ b/fs/ntfs3/inode.c
@@ -181,7 +181,7 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 		names += 1;
 		if (name && name->len == fname->name_len &&
 		    !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len,
-					NULL))
+					NULL, false))
 			is_match = true;
 
 		goto next_attr;
@@ -408,6 +408,7 @@ static struct inode *ntfs_read_mft(struct inode *inode,
 		inode->i_op = &ntfs_dir_inode_operations;
 		inode->i_fop = &ntfs_dir_operations;
 		ni->i_valid = 0;
+		init_rwsem(&ni->dir.run_lock);
 	} else if (S_ISLNK(mode)) {
 		ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY;
 		inode->i_op = &ntfs_link_inode_operations;
@@ -1116,7 +1117,7 @@ ntfs_create_reparse_buffer(struct ntfs_sb_info *sbi, const char *symname,
 	__le16 *rp_name;
 	typeof(rp->SymbolicLinkReparseBuffer) *rs;
 
-	rp = ntfs_alloc(ntfs_reparse_bytes(2 * size + 2), 1);
+	rp = ntfs_zalloc(ntfs_reparse_bytes(2 * size + 2));
 	if (!rp)
 		return ERR_PTR(-ENOMEM);
 
@@ -1561,6 +1562,7 @@ int ntfs_create_inode(struct inode *dir, struct dentry *dentry,
 			mode |= S_ISGID;
 		inode->i_op = &ntfs_dir_inode_operations;
 		inode->i_fop = &ntfs_dir_operations;
+		init_rwsem(&ni->dir.run_lock);
 	} else if (is_link) {
 		inode->i_op = &ntfs_link_inode_operations;
 		inode->i_fop = NULL;
@@ -1761,8 +1763,6 @@ int ntfs_unlink_inode(struct inode *dir, const struct dentry *dentry)
 	if (err < 0)
 		goto out4;
 
-	le = NULL;
-
 	/*mark rw ntfs as dirty. it will be cleared at umount*/
 	ntfs_set_state(sbi, NTFS_DIRTY_DIRTY);
 
@@ -1776,6 +1776,7 @@ int ntfs_unlink_inode(struct inode *dir, const struct dentry *dentry)
 #endif
 	ref.seq = dir_ni->mi.mrec->seq;
 
+	le = NULL;
 	fname = ni_fname_name(ni, uni, &ref, &le);
 	if (!fname) {
 		err = -ENOENT;
@@ -1887,7 +1888,7 @@ static noinline int ntfs_readlink_hlp(struct inode *inode, char *buffer,
 			goto out;
 		}
 	} else {
-		rp = ntfs_alloc(i_size, 0);
+		rp = ntfs_malloc(i_size);
 		if (!rp) {
 			err = -ENOMEM;
 			goto out;
diff --git a/fs/ntfs3/lznt.c b/fs/ntfs3/lznt.c
index edba953b7..73dc108c3 100644
--- a/fs/ntfs3/lznt.c
+++ b/fs/ntfs3/lznt.c
@@ -294,8 +294,8 @@ static inline ssize_t decompress_chunk(u8 *unc, u8 *unc_end, const u8 *cmpr,
  */
 struct lznt *get_lznt_ctx(int level)
 {
-	struct lznt *r = ntfs_alloc(
-		level ? offsetof(struct lznt, hash) : sizeof(struct lznt), 1);
+	struct lznt *r = ntfs_zalloc(level ? offsetof(struct lznt, hash) :
+					     sizeof(struct lznt));
 
 	if (r)
 		r->std = !level;
diff --git a/fs/ntfs3/ntfs.h b/fs/ntfs3/ntfs.h
index 9b1a9be80..19aac05ff 100644
--- a/fs/ntfs3/ntfs.h
+++ b/fs/ntfs3/ntfs.h
@@ -76,6 +76,7 @@ static_assert(sizeof(size_t) == 8);
 typedef u32 CLST;
 #endif
 
+#define SPARSE_LCN64   ((u64)-1)
 #define SPARSE_LCN     ((CLST)-1)
 #define RESIDENT_LCN   ((CLST)-2)
 #define COMPRESSED_LCN ((CLST)-3)
diff --git a/fs/ntfs3/ntfs_fs.h b/fs/ntfs3/ntfs_fs.h
index 8fa5bd9ec..166a4937a 100644
--- a/fs/ntfs3/ntfs_fs.h
+++ b/fs/ntfs3/ntfs_fs.h
@@ -144,6 +144,8 @@ enum index_mutex_classed {
 struct ntfs_index {
 	struct runs_tree bitmap_run;
 	struct runs_tree alloc_run;
+	/* read/write access to 'bitmap_run'/'alloc_run' while ntfs_readdir */
+	struct rw_semaphore run_lock;
 
 	/*TODO: remove 'cmp'*/
 	NTFS_CMP_FUNC cmp;
@@ -323,6 +325,11 @@ struct ntfs_inode {
 	 */
 	struct rb_root mi_tree;
 
+	/*
+	 * This member is used in ntfs_readdir to ensure that all subrecords are loaded
+	 */
+	u8 mi_loaded;
+
 	union {
 		struct ntfs_index dir;
 		struct {
@@ -387,8 +394,9 @@ int attr_data_write_resident(struct ntfs_inode *ni, struct page *page);
 int attr_load_runs_vcn(struct ntfs_inode *ni, enum ATTR_TYPE type,
 		       const __le16 *name, u8 name_len, struct runs_tree *run,
 		       CLST vcn);
-int attr_wof_load_runs_range(struct ntfs_inode *ni, struct runs_tree *run,
-			     u64 from, u64 to);
+int attr_load_runs_range(struct ntfs_inode *ni, enum ATTR_TYPE type,
+			 const __le16 *name, u8 name_len, struct runs_tree *run,
+			 u64 from, u64 to);
 int attr_wof_frame_info(struct ntfs_inode *ni, struct ATTRIB *attr,
 			struct runs_tree *run, u64 frame, u64 frames,
 			u8 frame_bits, u32 *ondisk_size, u64 *vbo_data);
@@ -446,7 +454,6 @@ int ntfs_getattr(const struct path *path, struct kstat *stat, u32 request_mask,
 		 u32 flags);
 void ntfs_sparse_cluster(struct inode *inode, struct page *page0, CLST vcn,
 			 CLST len);
-int ntfs_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync);
 int ntfs3_setattr(struct dentry *dentry, struct iattr *attr);
 int ntfs_file_open(struct inode *inode, struct file *file);
 int ntfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
@@ -743,9 +750,9 @@ int ntfs_trim_fs(struct ntfs_sb_info *sbi, struct fstrim_range *range);
 
 /* globals from upcase.c */
 int ntfs_cmp_names(const __le16 *s1, size_t l1, const __le16 *s2, size_t l2,
-		   const u16 *upcase);
+		   const u16 *upcase, bool bothcase);
 int ntfs_cmp_names_cpu(const struct cpu_str *uni1, const struct le_str *uni2,
-		       const u16 *upcase);
+		       const u16 *upcase, bool bothcase);
 
 /* globals from xattr.c */
 #ifdef CONFIG_NTFS3_FS_POSIX_ACL
@@ -828,7 +835,7 @@ static inline void run_init(struct runs_tree *run)
 
 static inline struct runs_tree *run_alloc(void)
 {
-	return ntfs_alloc(sizeof(struct runs_tree), 1);
+	return ntfs_zalloc(sizeof(struct runs_tree));
 }
 
 static inline void run_close(struct runs_tree *run)
diff --git a/fs/ntfs3/record.c b/fs/ntfs3/record.c
index cca71ca82..7727e5081 100644
--- a/fs/ntfs3/record.c
+++ b/fs/ntfs3/record.c
@@ -26,16 +26,9 @@ static inline int compare_attr(const struct ATTRIB *left, enum ATTR_TYPE type,
 
 	/*
 	 * They have the same type code, so we have to compare the names.
-	 * First compare case insensitive
 	 */
-	diff = ntfs_cmp_names(attr_name(left), left->name_len, name, name_len,
-			      upcase);
-	if (diff)
-		return diff;
-
-	/* Second compare case sensitive */
 	return ntfs_cmp_names(attr_name(left), left->name_len, name, name_len,
-			      NULL);
+			      upcase, true);
 }
 
 /*
@@ -83,15 +76,18 @@ static __le16 mi_new_attt_id(struct mft_inode *mi)
 int mi_get(struct ntfs_sb_info *sbi, CLST rno, struct mft_inode **mi)
 {
 	int err;
-	struct mft_inode *m = ntfs_alloc(sizeof(struct mft_inode), 1);
+	struct mft_inode *m = ntfs_zalloc(sizeof(struct mft_inode));
 
 	if (!m)
 		return -ENOMEM;
 
 	err = mi_init(m, sbi, rno);
-	if (!err)
-		err = mi_read(m, false);
+	if (err) {
+		ntfs_free(m);
+		return err;
+	}
 
+	err = mi_read(m, false);
 	if (err) {
 		mi_put(m);
 		return err;
@@ -111,7 +107,7 @@ int mi_init(struct mft_inode *mi, struct ntfs_sb_info *sbi, CLST rno)
 {
 	mi->sbi = sbi;
 	mi->rno = rno;
-	mi->mrec = ntfs_alloc(sbi->record_size, 0);
+	mi->mrec = ntfs_malloc(sbi->record_size);
 	if (!mi->mrec)
 		return -ENOMEM;
 
@@ -207,27 +203,29 @@ struct ATTRIB *mi_enum_attr(struct mft_inode *mi, struct ATTRIB *attr)
 		off = le16_to_cpu(rec->attr_off);
 
 		if (used > total)
-			goto out;
+			return NULL;
 
 		if (off >= used || off < MFTRECORD_FIXUP_OFFSET_1 ||
 		    !IsDwordAligned(off)) {
-			goto out;
+			return NULL;
 		}
 
 		/* Skip non-resident records */
 		if (!is_rec_inuse(rec))
-			goto out;
+			return NULL;
 
 		attr = Add2Ptr(rec, off);
 	} else {
 		/* Check if input attr inside record */
 		off = PtrOffset(rec, attr);
 		if (off >= used)
-			goto out;
+			return NULL;
 
 		asize = le32_to_cpu(attr->size);
-		if (asize < SIZEOF_RESIDENT)
-			goto out;
+		if (asize < SIZEOF_RESIDENT) {
+			/* Impossible 'cause we should not return such attribute */
+			return NULL;
+		}
 
 		attr = Add2Ptr(attr, asize);
 		off += asize;
@@ -238,36 +236,36 @@ struct ATTRIB *mi_enum_attr(struct mft_inode *mi, struct ATTRIB *attr)
 	/* Can we use the first field (attr->type) */
 	if (off + 8 > used) {
 		static_assert(QuadAlign(sizeof(enum ATTR_TYPE)) == 8);
-		goto out;
+		return NULL;
 	}
 
 	if (attr->type == ATTR_END) {
-		if (used != off + 8)
-			goto out;
+		/* end of enumeration */
 		return NULL;
 	}
 
+	/* 0x100 is last known attribute for now*/
 	t32 = le32_to_cpu(attr->type);
 	if ((t32 & 0xf) || (t32 > 0x100))
-		goto out;
+		return NULL;
 
 	/* Check boundary */
 	if (off + asize > used)
-		goto out;
+		return NULL;
 
 	/* Check size of attribute */
 	if (!attr->non_res) {
 		if (asize < SIZEOF_RESIDENT)
-			goto out;
+			return NULL;
 
 		t16 = le16_to_cpu(attr->res.data_off);
 
 		if (t16 > asize)
-			goto out;
+			return NULL;
 
 		t32 = le32_to_cpu(attr->res.data_size);
 		if (t16 + t32 > asize)
-			goto out;
+			return NULL;
 
 		return attr;
 	}
@@ -276,22 +274,19 @@ struct ATTRIB *mi_enum_attr(struct mft_inode *mi, struct ATTRIB *attr)
 	if (attr->name_len &&
 	    le16_to_cpu(attr->name_off) + sizeof(short) * attr->name_len >
 		    le16_to_cpu(attr->nres.run_off)) {
-		goto out;
+		return NULL;
 	}
 
 	if (attr->nres.svcn || !is_attr_ext(attr)) {
 		if (asize + 8 < SIZEOF_NONRESIDENT)
-			goto out;
+			return NULL;
 
 		if (attr->nres.c_unit)
-			goto out;
+			return NULL;
 	} else if (asize + 8 < SIZEOF_NONRESIDENT_EX)
-		goto out;
+		return NULL;
 
 	return attr;
-
-out:
-	return NULL;
 }
 
 /*
diff --git a/fs/ntfs3/run.c b/fs/ntfs3/run.c
index 2b1eeb980..27efd0ad5 100644
--- a/fs/ntfs3/run.c
+++ b/fs/ntfs3/run.c
@@ -386,7 +386,7 @@ bool run_add_entry(struct runs_tree *run, CLST vcn, CLST lcn, CLST len,
 
 			WARN_ON(!is_mft && bytes > NTFS3_RUN_MAX_BYTES);
 
-			new_ptr = ntfs_alloc(bytes, 0);
+			new_ptr = ntfs_malloc(bytes);
 
 			if (!new_ptr)
 				return false;
@@ -575,12 +575,12 @@ bool run_get_entry(const struct runs_tree *run, size_t index, CLST *vcn,
  *
  * calculates the size of packed int64
  */
-static inline int run_packed_size(const s64 *n)
-{
 #ifdef __BIG_ENDIAN
-	const u8 *p = (const u8 *)n + sizeof(*n) - 1;
+static inline int run_packed_size(const s64 n)
+{
+	const u8 *p = (const u8 *)&n + sizeof(n) - 1;
 
-	if (*n >= 0) {
+	if (n >= 0) {
 		if (p[-7] || p[-6] || p[-5] || p[-4])
 			p -= 4;
 		if (p[-3] || p[-2])
@@ -600,11 +600,81 @@ static inline int run_packed_size(const s64 *n)
 		if (!(p[0] & 0x80))
 			p -= 1;
 	}
-	return (const u8 *)n + sizeof(*n) - p;
+	return (const u8 *)n + sizeof(n) - p;
+}
+
+/* full trusted function. It does not check 'size' for errors */
+static inline void run_pack_s64(u8 *run_buf, u8 size, s64 v)
+{
+	const u8 *p = (u8 *)&v;
+
+	switch (size) {
+	case 8:
+		run_buf[7] = p[0];
+		fallthrough;
+	case 7:
+		run_buf[6] = p[1];
+		fallthrough;
+	case 6:
+		run_buf[5] = p[2];
+		fallthrough;
+	case 5:
+		run_buf[4] = p[3];
+		fallthrough;
+	case 4:
+		run_buf[3] = p[4];
+		fallthrough;
+	case 3:
+		run_buf[2] = p[5];
+		fallthrough;
+	case 2:
+		run_buf[1] = p[6];
+		fallthrough;
+	case 1:
+		run_buf[0] = p[7];
+	}
+}
+
+/* full trusted function. It does not check 'size' for errors */
+static inline s64 run_unpack_s64(const u8 *run_buf, u8 size, s64 v)
+{
+	u8 *p = (u8 *)&v;
+
+	switch (size) {
+	case 8:
+		p[0] = run_buf[7];
+		fallthrough;
+	case 7:
+		p[1] = run_buf[6];
+		fallthrough;
+	case 6:
+		p[2] = run_buf[5];
+		fallthrough;
+	case 5:
+		p[3] = run_buf[4];
+		fallthrough;
+	case 4:
+		p[4] = run_buf[3];
+		fallthrough;
+	case 3:
+		p[5] = run_buf[2];
+		fallthrough;
+	case 2:
+		p[6] = run_buf[1];
+		fallthrough;
+	case 1:
+		p[7] = run_buf[0];
+	}
+	return v;
+}
+
 #else
-	const u8 *p = (const u8 *)n;
 
-	if (*n >= 0) {
+static inline int run_packed_size(const s64 n)
+{
+	const u8 *p = (const u8 *)&n;
+
+	if (n >= 0) {
 		if (p[7] || p[6] || p[5] || p[4])
 			p += 4;
 		if (p[3] || p[2])
@@ -625,10 +695,77 @@ static inline int run_packed_size(const s64 *n)
 			p += 1;
 	}
 
-	return 1 + p - (const u8 *)n;
-#endif
+	return 1 + p - (const u8 *)&n;
 }
 
+/* full trusted function. It does not check 'size' for errors */
+static inline void run_pack_s64(u8 *run_buf, u8 size, s64 v)
+{
+	const u8 *p = (u8 *)&v;
+
+	/* memcpy( run_buf, &v, size); is it faster? */
+	switch (size) {
+	case 8:
+		run_buf[7] = p[7];
+		fallthrough;
+	case 7:
+		run_buf[6] = p[6];
+		fallthrough;
+	case 6:
+		run_buf[5] = p[5];
+		fallthrough;
+	case 5:
+		run_buf[4] = p[4];
+		fallthrough;
+	case 4:
+		run_buf[3] = p[3];
+		fallthrough;
+	case 3:
+		run_buf[2] = p[2];
+		fallthrough;
+	case 2:
+		run_buf[1] = p[1];
+		fallthrough;
+	case 1:
+		run_buf[0] = p[0];
+	}
+}
+
+/* full trusted function. It does not check 'size' for errors */
+static inline s64 run_unpack_s64(const u8 *run_buf, u8 size, s64 v)
+{
+	u8 *p = (u8 *)&v;
+
+	/* memcpy( &v, run_buf, size); is it faster? */
+	switch (size) {
+	case 8:
+		p[7] = run_buf[7];
+		fallthrough;
+	case 7:
+		p[6] = run_buf[6];
+		fallthrough;
+	case 6:
+		p[5] = run_buf[5];
+		fallthrough;
+	case 5:
+		p[4] = run_buf[4];
+		fallthrough;
+	case 4:
+		p[3] = run_buf[3];
+		fallthrough;
+	case 3:
+		p[2] = run_buf[2];
+		fallthrough;
+	case 2:
+		p[1] = run_buf[1];
+		fallthrough;
+	case 1:
+		p[0] = run_buf[0];
+	}
+	return v;
+}
+#endif
+
 /*
  * run_pack
  *
@@ -645,9 +782,8 @@ int run_pack(const struct runs_tree *run, CLST svcn, CLST len, u8 *run_buf,
 	int packed_size = 0;
 	size_t i;
 	bool ok;
-	s64 dlcn, len64;
-	int offset_size, size_size, t;
-	const u8 *p;
+	s64 dlcn;
+	int offset_size, size_size, tmp;
 
 	next_vcn = vcn = svcn;
 
@@ -665,156 +801,43 @@ int run_pack(const struct runs_tree *run, CLST svcn, CLST len, u8 *run_buf,
 		goto error;
 
 	for (;;) {
-		/* offset of current fragment relatively to previous fragment */
-		dlcn = 0;
 		next_vcn = vcn + len;
-
 		if (next_vcn > evcn1)
 			len = evcn1 - vcn;
 
-		/*
-		 * mirror of len, but signed, because run_packed_size()
-		 * works with signed int only
-		 */
-		len64 = len;
-
-		/* how much bytes is packed len64 */
-		size_size = run_packed_size(&len64);
+		/* how much bytes required to pack len */
+		size_size = run_packed_size(len);
 
 		/* offset_size - how much bytes is packed dlcn */
 		if (lcn == SPARSE_LCN) {
 			offset_size = 0;
+			dlcn = 0;
 		} else {
 			/* NOTE: lcn can be less than prev_lcn! */
 			dlcn = (s64)lcn - prev_lcn;
-			offset_size = run_packed_size(&dlcn);
+			offset_size = run_packed_size(dlcn);
 			prev_lcn = lcn;
 		}
 
-		t = run_buf_size - packed_size - 2 - offset_size;
-		if (t <= 0)
+		tmp = run_buf_size - packed_size - 2 - offset_size;
+		if (tmp <= 0)
 			goto out;
 
 		/* can we store this entire run */
-		if (t < size_size)
+		if (tmp < size_size)
 			goto out;
 
 		if (run_buf) {
-			p = (u8 *)&len64;
-
 			/* pack run header */
 			run_buf[0] = ((u8)(size_size | (offset_size << 4)));
 			run_buf += 1;
 
 			/* Pack the length of run */
-			switch (size_size) {
-#ifdef __BIG_ENDIAN
-			case 8:
-				run_buf[7] = p[0];
-				fallthrough;
-			case 7:
-				run_buf[6] = p[1];
-				fallthrough;
-			case 6:
-				run_buf[5] = p[2];
-				fallthrough;
-			case 5:
-				run_buf[4] = p[3];
-				fallthrough;
-			case 4:
-				run_buf[3] = p[4];
-				fallthrough;
-			case 3:
-				run_buf[2] = p[5];
-				fallthrough;
-			case 2:
-				run_buf[1] = p[6];
-				fallthrough;
-			case 1:
-				run_buf[0] = p[7];
-#else
-			case 8:
-				run_buf[7] = p[7];
-				fallthrough;
-			case 7:
-				run_buf[6] = p[6];
-				fallthrough;
-			case 6:
-				run_buf[5] = p[5];
-				fallthrough;
-			case 5:
-				run_buf[4] = p[4];
-				fallthrough;
-			case 4:
-				run_buf[3] = p[3];
-				fallthrough;
-			case 3:
-				run_buf[2] = p[2];
-				fallthrough;
-			case 2:
-				run_buf[1] = p[1];
-				fallthrough;
-			case 1:
-				run_buf[0] = p[0];
-#endif
-			}
+			run_pack_s64(run_buf, size_size, len);
 
 			run_buf += size_size;
-			p = (u8 *)&dlcn;
-
 			/* Pack the offset from previous lcn */
-			switch (offset_size) {
-#ifdef __BIG_ENDIAN
-			case 8:
-				run_buf[7] = p[0];
-				fallthrough;
-			case 7:
-				run_buf[6] = p[1];
-				fallthrough;
-			case 6:
-				run_buf[5] = p[2];
-				fallthrough;
-			case 5:
-				run_buf[4] = p[3];
-				fallthrough;
-			case 4:
-				run_buf[3] = p[4];
-				fallthrough;
-			case 3:
-				run_buf[2] = p[5];
-				fallthrough;
-			case 2:
-				run_buf[1] = p[6];
-				fallthrough;
-			case 1:
-				run_buf[0] = p[7];
-#else
-			case 8:
-				run_buf[7] = p[7];
-				fallthrough;
-			case 7:
-				run_buf[6] = p[6];
-				fallthrough;
-			case 6:
-				run_buf[5] = p[5];
-				fallthrough;
-			case 5:
-				run_buf[4] = p[4];
-				fallthrough;
-			case 4:
-				run_buf[3] = p[3];
-				fallthrough;
-			case 3:
-				run_buf[2] = p[2];
-				fallthrough;
-			case 2:
-				run_buf[1] = p[1];
-				fallthrough;
-			case 1:
-				run_buf[0] = p[0];
-#endif
-			}
-
+			run_pack_s64(run_buf, offset_size, dlcn);
 			run_buf += offset_size;
 		}
 
@@ -876,9 +899,7 @@ int run_unpack(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,
 		u8 size_size = *run_buf & 0xF;
 		/* offset_size - how much bytes is packed dlcn */
 		u8 offset_size = *run_buf++ >> 4;
-		u64 len = 0;
-		u8 *p = (u8 *)&len;
-		s64 dlcn;
+		u64 len;
 
 		if (!size_size)
 			break;
@@ -890,156 +911,60 @@ int run_unpack(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,
 		 * Large positive number requires to store 5 bytes
 		 * e.g.: 05 FF 7E FF FF 00 00 00
 		 */
-
-		switch (size_size) {
-		default:
-error:
+		if (size_size > 8)
 			return -EINVAL;
 
-#ifdef __BIG_ENDIAN
-		case 8:
-			p[0] = run_buf[7];
-			fallthrough;
-		case 7:
-			p[1] = run_buf[6];
-			fallthrough;
-		case 6:
-			p[2] = run_buf[5];
-			fallthrough;
-		case 5:
-			p[3] = run_buf[4];
-			fallthrough;
-		case 4:
-			p[4] = run_buf[3];
-			fallthrough;
-		case 3:
-			p[5] = run_buf[2];
-			fallthrough;
-		case 2:
-			p[6] = run_buf[1];
-			fallthrough;
-		case 1:
-			p[7] = run_buf[0];
-#else
-		case 8:
-			p[7] = run_buf[7];
-			fallthrough;
-		case 7:
-			p[6] = run_buf[6];
-			fallthrough;
-		case 6:
-			p[5] = run_buf[5];
-			fallthrough;
-		case 5:
-			p[4] = run_buf[4];
-			fallthrough;
-		case 4:
-			p[3] = run_buf[3];
-			fallthrough;
-		case 3:
-			p[2] = run_buf[2];
-			fallthrough;
-		case 2:
-			p[1] = run_buf[1];
-			fallthrough;
-		case 1:
-			p[0] = run_buf[0];
-#endif
-		}
-
+		len = run_unpack_s64(run_buf, size_size, 0);
 		/* skip size_size */
 		run_buf += size_size;
 
 		if (!len)
-			goto error;
-
-		if (!offset_size) {
-			lcn = SPARSE_LCN;
-		} else {
-			/* Check sign */
-			dlcn = (run_buf[offset_size - 1] & 0x80) ? (s64)-1 : 0;
-
-			p = (u8 *)&dlcn;
-
-			switch (offset_size) {
-			default:
-				goto error;
+			return -EINVAL;
 
-#ifdef __BIG_ENDIAN
-			case 8:
-				p[0] = run_buf[7];
-				fallthrough;
-			case 7:
-				p[1] = run_buf[6];
-				fallthrough;
-			case 6:
-				p[2] = run_buf[5];
-				fallthrough;
-			case 5:
-				p[3] = run_buf[4];
-				fallthrough;
-			case 4:
-				p[4] = run_buf[3];
-				fallthrough;
-			case 3:
-				p[5] = run_buf[2];
-				fallthrough;
-			case 2:
-				p[6] = run_buf[1];
-				fallthrough;
-			case 1:
-				p[7] = run_buf[0];
-#else
-			case 8:
-				p[7] = run_buf[7];
-				fallthrough;
-			case 7:
-				p[6] = run_buf[6];
-				fallthrough;
-			case 6:
-				p[5] = run_buf[5];
-				fallthrough;
-			case 5:
-				p[4] = run_buf[4];
-				fallthrough;
-			case 4:
-				p[3] = run_buf[3];
-				fallthrough;
-			case 3:
-				p[2] = run_buf[2];
-				fallthrough;
-			case 2:
-				p[1] = run_buf[1];
-				fallthrough;
-			case 1:
-				p[0] = run_buf[0];
-#endif
-			}
+		if (!offset_size)
+			lcn = SPARSE_LCN64;
+		else if (offset_size <= 8) {
+			s64 dlcn;
 
+			/* initial value of dlcn is -1 or 0 */
+			dlcn = (run_buf[offset_size - 1] & 0x80) ? (s64)-1 : 0;
+			dlcn = run_unpack_s64(run_buf, offset_size, dlcn);
 			/* skip offset_size */
 			run_buf += offset_size;
+
+			if (!dlcn)
+				return -EINVAL;
 			lcn = prev_lcn + dlcn;
 			prev_lcn = lcn;
-		}
+		} else
+			return -EINVAL;
 
 		next_vcn = vcn64 + len;
 		/* check boundary */
 		if (next_vcn > evcn + 1)
-			goto error;
+			return -EINVAL;
 
 #ifndef NTFS3_64BIT_CLUSTER
-		if ((vcn64 >> 32)
-		    /* 0xffffffffffffffff is a valid 'lcn' */
-		    || (lcn + 1) > 0x100000000ull || (len >> 32)) {
-			goto error;
+		if (next_vcn > 0x100000000ull || (lcn + len) > 0x100000000ull) {
+			ntfs_err(
+				sbi->sb,
+				"This driver is compiled whitout NTFS3_64BIT_CLUSTER (like windows driver).\n"
+				"Volume contains 64 bits run: vcn %llx, lcn %llx, len %llx.\n"
+				"Activate NTFS3_64BIT_CLUSTER to process this case",
+				vcn64, lcn, len);
+			return -EOPNOTSUPP;
 		}
 #endif
+		if (lcn != SPARSE_LCN64 && lcn + len > sbi->used.bitmap.nbits) {
+			/* lcn range is out of volume */
+			return -EINVAL;
+		}
 
 		if (!run)
 			; /* called from check_attr(fslog.c) to check run */
 		else if (run == RUN_DEALLOCATE) {
 			/* called from ni_delete_all to free clusters without storing in run */
-			if (lcn != SPARSE_LCN)
+			if (lcn != SPARSE_LCN64)
 				mark_as_free_ex(sbi, lcn, len, true);
 		} else if (vcn64 >= vcn) {
 			if (!run_add_entry(run, vcn64, lcn, len, is_mft))
@@ -1052,17 +977,15 @@ int run_unpack(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,
 				return -ENOMEM;
 		}
 
-		if (lcn != SPARSE_LCN && lcn + len > sbi->used.bitmap.nbits)
-			return -EINVAL;
-
 		vcn64 = next_vcn;
 	}
 
-	/* Check vcn consistency */
-	if (vcn64 == evcn + 1)
-		return run_buf - run_0;
+	if (vcn64 != evcn + 1) {
+		/* not expected length of unpacked runs */
+		return -EINVAL;
+	}
 
-	return -EINVAL;
+	return run_buf - run_0;
 }
 
 #ifdef NTFS3_CHECK_FREE_CLST
@@ -1169,84 +1092,27 @@ int run_unpack_ex(struct runs_tree *run, struct ntfs_sb_info *sbi, CLST ino,
  */
 int run_get_highest_vcn(CLST vcn, const u8 *run_buf, u64 *highest_vcn)
 {
-	const u8 *run = run_buf;
 	u64 vcn64 = vcn;
 	u8 size_size;
 
-	while ((size_size = *run & 0xF)) {
-		u8 offset_size = *run++ >> 4;
-		u64 len = 0;
-		u8 *p = (u8 *)&len;
+	while ((size_size = *run_buf & 0xF)) {
+		u8 offset_size = *run_buf++ >> 4;
+		u64 len;
 
-		switch (size_size) {
-		default:
-error:
+		if (size_size > 8 || offset_size > 8)
 			return -EINVAL;
 
-#ifdef __BIG_ENDIAN
-		case 8:
-			p[0] = run[7];
-			fallthrough;
-		case 7:
-			p[1] = run[6];
-			fallthrough;
-		case 6:
-			p[2] = run[5];
-			fallthrough;
-		case 5:
-			p[3] = run[4];
-			fallthrough;
-		case 4:
-			p[4] = run[3];
-			fallthrough;
-		case 3:
-			p[5] = run[2];
-			fallthrough;
-		case 2:
-			p[6] = run[1];
-			fallthrough;
-		case 1:
-			p[7] = run[0];
-#else
-		case 8:
-			p[7] = run[7];
-			fallthrough;
-		case 7:
-			p[6] = run[6];
-			fallthrough;
-		case 6:
-			p[5] = run[5];
-			fallthrough;
-		case 5:
-			p[4] = run[4];
-			fallthrough;
-		case 4:
-			p[3] = run[3];
-			fallthrough;
-		case 3:
-			p[2] = run[2];
-			fallthrough;
-		case 2:
-			p[1] = run[1];
-			fallthrough;
-		case 1:
-			p[0] = run[0];
-#endif
-		}
-
-		/* skip size_size */
-		run += size_size;
-
+		len = run_unpack_s64(run_buf, size_size, 0);
 		if (!len)
-			goto error;
+			return -EINVAL;
 
-		run += offset_size;
+		run_buf += size_size + offset_size;
+		vcn64 += len;
 
-#ifdef NTFS3_64BIT_CLUSTER
-		if ((vcn >> 32) || (len >> 32))
-			goto error;
+#ifndef NTFS3_64BIT_CLUSTER
+		if (vcn64 > 0x100000000ull)
+			return -EINVAL;
 #endif
-		vcn64 += len;
 	}
 
 	*highest_vcn = vcn64 - 1;
diff --git a/fs/ntfs3/super.c b/fs/ntfs3/super.c
index f53c3f770..9d9e597c3 100644
--- a/fs/ntfs3/super.c
+++ b/fs/ntfs3/super.c
@@ -848,7 +848,7 @@ static int ntfs_init_from_boot(struct super_block *sb, u32 sector_size,
 
 	sbi->used.bitmap.nbits = clusters;
 
-	rec = ntfs_alloc(record_size, 1);
+	rec = ntfs_zalloc(record_size);
 	if (!rec) {
 		err = -ENOMEM;
 		goto out;
@@ -915,7 +915,7 @@ static int ntfs_fill_super(struct super_block *sb, void *data, int silent)
 
 	ref.high = 0;
 
-	sbi = ntfs_alloc(sizeof(struct ntfs_sb_info), true);
+	sbi = ntfs_zalloc(sizeof(struct ntfs_sb_info));
 	if (!sbi)
 		return -ENOMEM;
 
@@ -978,7 +978,7 @@ static int ntfs_fill_super(struct super_block *sb, void *data, int silent)
 	attr = ni_find_attr(ni, NULL, NULL, ATTR_LABEL, NULL, 0, NULL, NULL);
 
 	if (!attr) {
-		;
+		/* It is ok if no ATTR_LABEL */
 	} else if (!attr->non_res && !is_attr_ext(attr)) {
 		/* $AttrDef allows labels to be up to 128 symbols */
 		err = utf16s_to_utf8s(resident_data(attr),
@@ -1176,7 +1176,7 @@ static int ntfs_fill_super(struct super_block *sb, void *data, int silent)
 		goto out;
 	}
 	bytes = inode->i_size;
-	sbi->def_table = t = ntfs_alloc(bytes, 0);
+	sbi->def_table = t = ntfs_malloc(bytes);
 	if (!t) {
 		err = -ENOMEM;
 		goto out;
@@ -1238,7 +1238,7 @@ static int ntfs_fill_super(struct super_block *sb, void *data, int silent)
 		goto out;
 	}
 
-	sbi->upcase = upcase = ntfs_alloc(0x10000 * sizeof(short), 0);
+	sbi->upcase = upcase = ntfs_malloc(0x10000 * sizeof(short));
 	if (!upcase) {
 		err = -ENOMEM;
 		goto out;
@@ -1454,6 +1454,8 @@ static int __init init_ntfs_fs(void)
 	if (!err)
 		return 0;
 
+	kmem_cache_destroy(ntfs_inode_cachep);
+
 failed:
 	return err;
 }
diff --git a/fs/ntfs3/upcase.c b/fs/ntfs3/upcase.c
index 87b65f9cc..270458fc7 100644
--- a/fs/ntfs3/upcase.c
+++ b/fs/ntfs3/upcase.c
@@ -24,54 +24,77 @@ static inline u16 upcase_unicode_char(const u16 *upcase, u16 chr)
 	return upcase[chr];
 }
 
+/* Thanks Kari Argillander <kari.argillander@gmail.com> for idea and implementation 'bothcase' */
 int ntfs_cmp_names(const __le16 *s1, size_t l1, const __le16 *s2, size_t l2,
-		   const u16 *upcase)
+		   const u16 *upcase, bool bothcase)
 {
-	int diff;
+	int diff1 = 0;
+	int diff2;
 	size_t len = l1 < l2 ? l1 : l2;
 
-	if (upcase) {
-		while (len--) {
-			diff = upcase_unicode_char(upcase, le16_to_cpu(*s1++)) -
-			       upcase_unicode_char(upcase, le16_to_cpu(*s2++));
-			if (diff)
-				return diff;
-		}
-	} else {
-		while (len--) {
-			diff = le16_to_cpu(*s1++) - le16_to_cpu(*s2++);
-			if (diff)
-				return diff;
+	if (!bothcase && upcase)
+		goto case_insentive;
+
+	for (; len; s1++, s2++, len--) {
+		diff1 = le16_to_cpu(*s1) - le16_to_cpu(*s2);
+		if (diff1) {
+			if (bothcase && upcase)
+				goto case_insentive;
+
+			return diff1;
 		}
 	}
+	return l1 - l2;
+
+case_insentive:
+	for (; len; s1++, s2++, len--) {
+		diff2 = upcase_unicode_char(upcase, le16_to_cpu(*s1)) -
+			upcase_unicode_char(upcase, le16_to_cpu(*s2));
+		if (diff2)
+			return diff2;
+	}
 
-	return (int)(l1 - l2);
+	if (bothcase && diff1)
+		return diff1;
+
+	return l1 - l2;
 }
 
 int ntfs_cmp_names_cpu(const struct cpu_str *uni1, const struct le_str *uni2,
-		       const u16 *upcase)
+		       const u16 *upcase, bool bothcase)
 {
 	const u16 *s1 = uni1->name;
 	const __le16 *s2 = uni2->name;
 	size_t l1 = uni1->len;
 	size_t l2 = uni2->len;
 	size_t len = l1 < l2 ? l1 : l2;
-	int diff;
-
-	if (upcase) {
-		while (len--) {
-			diff = upcase_unicode_char(upcase, *s1++) -
-			       upcase_unicode_char(upcase, le16_to_cpu(*s2++));
-			if (diff)
-				return diff;
-		}
-	} else {
-		while (len--) {
-			diff = *s1++ - le16_to_cpu(*s2++);
-			if (diff)
-				return diff;
+	int diff1 = 0;
+	int diff2;
+
+	if (!bothcase && upcase)
+		goto case_insentive;
+
+	for (; len; s1++, s2++, len--) {
+		diff1 = *s1 - le16_to_cpu(*s2);
+		if (diff1) {
+			if (bothcase && upcase)
+				goto case_insentive;
+
+			return diff1;
 		}
 	}
+	return l1 - l2;
+
+case_insentive:
+	for (; len; s1++, s2++, len--) {
+		diff2 = upcase_unicode_char(upcase, *s1) -
+			upcase_unicode_char(upcase, le16_to_cpu(*s2));
+		if (diff2)
+			return diff2;
+	}
+
+	if (bothcase && diff1)
+		return diff1;
 
 	return l1 - l2;
 }
diff --git a/fs/ntfs3/xattr.c b/fs/ntfs3/xattr.c
index 86f95c166..cc69295eb 100644
--- a/fs/ntfs3/xattr.c
+++ b/fs/ntfs3/xattr.c
@@ -107,7 +107,7 @@ static int ntfs_read_ea(struct ntfs_inode *ni, struct EA_FULL **ea,
 		return -EINVAL;
 
 	/* Allocate memory for packed Ea */
-	ea_p = ntfs_alloc(size + add_bytes, 0);
+	ea_p = ntfs_malloc(size + add_bytes);
 	if (!ea_p)
 		return -ENOMEM;
 
@@ -355,7 +355,7 @@ static noinline int ntfs_set_ea(struct inode *inode, const char *name,
 		}
 
 		if (!ea_all) {
-			ea_all = ntfs_alloc(add, 1);
+			ea_all = ntfs_zalloc(add);
 			if (!ea_all) {
 				err = -ENOMEM;
 				goto out;
@@ -581,7 +581,7 @@ static noinline int ntfs_set_acl_ex(struct inode *inode, struct posix_acl *acl,
 		goto out;
 
 	size = posix_acl_xattr_size(acl->a_count);
-	value = ntfs_alloc(size, 0);
+	value = ntfs_malloc(size);
 	if (!value)
 		return -ENOMEM;
 
-- 
2.30.1.457.gf011795891

