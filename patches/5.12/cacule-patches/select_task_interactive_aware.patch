commit 87ef6d833095525154242f34d5e32a1999e61aac
Author: Hamad Marri <hamad.s.almarri@gmail.com>
Date:   Tue Apr 27 12:23:40 2021 +0300

    select_task_rq interactive aware

diff --git a/include/linux/sched/sysctl.h b/include/linux/sched/sysctl.h
index 774de59e8111..f8db1089180b 100644
--- a/include/linux/sched/sysctl.h
+++ b/include/linux/sched/sysctl.h
@@ -33,6 +33,7 @@ extern unsigned int sysctl_sched_child_runs_first;
 
 #ifdef CONFIG_CACULE_SCHED
 extern int interactivity_factor;
+extern unsigned int interactivity_threshold;
 extern int cacule_max_lifetime;
 extern int cacule_harsh_mode;
 #endif
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index ba07c1571b82..3282441b6732 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -130,6 +130,7 @@ int __weak arch_asym_cpu_priority(int cpu)
 int cacule_max_lifetime					= 30000; // in ms
 int cacule_harsh_mode					= 0;
 int interactivity_factor				= 32768;
+unsigned int interactivity_threshold			= 20480;
 #endif
 
 #ifdef CONFIG_CFS_BANDWIDTH
@@ -630,6 +631,14 @@ calc_interactivity(u64 now, struct cacule_node *se)
 	return score_se;
 }
 
+static inline int is_interactive(struct cacule_node *cn)
+{
+	if (cn->vruntime == 0)
+		return 0;
+
+	return calc_interactivity(sched_clock(), cn) < interactivity_threshold;
+}
+
 static inline int
 entity_before_cached(u64 now, unsigned int score_curr, struct cacule_node *se)
 {
@@ -7085,7 +7094,55 @@ select_task_rq_fair(struct task_struct *p, int prev_cpu, int wake_flags)
 	/* SD_flags and WF_flags share the first nibble */
 	int sd_flag = wake_flags & 0xF;
 
-#if !defined(CONFIG_CACULE_SCHED)
+#ifdef CONFIG_CACULE_SCHED
+	struct cfs_rq *cfs_rq;
+	struct sched_entity *se = &p->se;
+	unsigned int max_IS = 0;
+	unsigned int IS, IS_c, IS_h;
+	struct sched_entity *curr_se;
+	struct cacule_node *cn, *head;
+	int cpu_i;
+
+	if (!is_interactive(&se->cacule_node))
+		goto cfs_way;
+
+	for_each_online_cpu(cpu_i) {
+		if (!cpumask_test_cpu(cpu_i, p->cpus_ptr))
+			continue;
+
+		cn = NULL;
+		cfs_rq = &cpu_rq(cpu_i)->cfs;
+
+		curr_se = cfs_rq->curr;
+		head = cfs_rq->head;
+
+		if (!curr_se && head)
+			cn = head;
+		else if (curr_se && !head)
+			cn = &curr_se->cacule_node;
+		else if (curr_se && head) {
+			IS_c = calc_interactivity(sched_clock(), &curr_se->cacule_node);
+			IS_h = calc_interactivity(sched_clock(), head);
+
+			IS = IS_c > IS_h? IS_c : IS_h;
+			goto compare;
+		}
+
+		if (!cn)
+			return cpu_i;
+
+		IS = calc_interactivity(sched_clock(), cn);
+
+compare:
+		if (IS > max_IS) {
+			max_IS = IS;
+			new_cpu = cpu_i;
+		}
+	}
+
+	return new_cpu;
+cfs_way:
+#else
 	if (wake_flags & WF_TTWU) {
 		record_wakee(p);
 
@@ -7098,7 +7155,7 @@ select_task_rq_fair(struct task_struct *p, int prev_cpu, int wake_flags)
 
 		want_affine = !wake_wide(p) && cpumask_test_cpu(cpu, p->cpus_ptr);
 	}
-#endif
+#endif /* CONFIG_CACULE_SCHED */
 
 	rcu_read_lock();
 	for_each_domain(cpu, tmp) {
@@ -7134,7 +7191,7 @@ select_task_rq_fair(struct task_struct *p, int prev_cpu, int wake_flags)
 	rcu_read_unlock();
 
 	return new_cpu;
-#endif
+#endif /* CONFIG_CACULE_RDB */
 }
 
 #if !defined(CONFIG_CACULE_RDB)
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index c6b24b552656..e70d4946080d 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1667,6 +1667,13 @@ static struct ctl_table kern_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+	{
+		.procname	= "sched_interactivity_threshold",
+		.data		= &interactivity_threshold,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
 	{
 		.procname	= "sched_max_lifetime_ms",
 		.data		= &cacule_max_lifetime,
