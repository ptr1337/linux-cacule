From ee16a89380ea6e9001f6ab81bd00a42c31e13b15 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Mon, 31 May 2021 16:28:18 +0200
Subject: [PATCH 08/20] LRNG: update seeding threshold when loading DRNG only
 if min seeded

The update of the seeding threshold is only needed when the final
entropy threshold is set, i.e. when the LRNG is already minimally
seeded. If the threshold is set before, the minimally seeded threshold
is skipped.

Thus, only update the seeding threshold when loading a DRNG instance
and switching to it if the LRNG is minimally seeded.

Signed-off-by: Stephan Mueller <smueller@chronox.de>

[torvic9: adapted for kernel patch use]
---
 lrng_switch.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/char/lrng/lrng_switch.c b/drivers/char/lrng/lrng_switch.c
index a2b117b..c3868b7 100644
--- a/drivers/char/lrng/lrng_switch.c
+++ b/drivers/char/lrng/lrng_switch.c
@@ -111,8 +111,10 @@ static int lrng_drng_switch(struct lrng_drng *drng_store,
 		lrng_set_digestsize(cb->lrng_hash_digestsize(new_hash));
 		if (lrng_sp80090c_compliant())
 			additional = CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS;
-		lrng_set_entropy_thresh(lrng_security_strength() + additional +
-					CONFIG_LRNG_OVERSAMPLE_ES_BITS);
+		if (lrng_state_min_seeded()) {
+			lrng_set_entropy_thresh(lrng_security_strength() +
+						additional);
+		}
 
 		/* Reseed if previous LRNG security strength was insufficient */
 		if (current_security_strength < lrng_security_strength())
-- 
2.32.0

From 2ce193b4c63409b08965f466cc69a330669b6331 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Tue, 1 Jun 2021 07:33:53 +0200
Subject: [PATCH 09/20] LRNG: insert bootloader entropy directly into the aux
 pool

The boot loader entropy is provided very early in the boot cycle before
much of the infrastructure of the kernel is available. It is also
provided before the work queue mechanism is initialized. Thus, using
add_hwgenerator_randomness is not advisable.

The change therefore inserts the entropy directly into the auxiliary
pool without using any helper function

Reported-by: Alexander Lobakin <alobakin@mailbox.org>
Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_interfaces.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/drivers/char/lrng/lrng_interfaces.c b/drivers/char/lrng/lrng_interfaces.c
index 8121ba4..7102efa 100644
--- a/drivers/char/lrng/lrng_interfaces.c
+++ b/drivers/char/lrng/lrng_interfaces.c
@@ -150,10 +150,9 @@ EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
  */
 void add_bootloader_randomness(const void *buf, unsigned int size)
 {
-	if (IS_ENABLED(CONFIG_RANDOM_TRUST_BOOTLOADER))
-		add_hwgenerator_randomness(buf, size, size * 8);
-	else
-		add_device_randomness(buf, size);
+	lrng_pool_insert_aux(buf, size,
+			     IS_ENABLED(CONFIG_RANDOM_TRUST_BOOTLOADER) ?
+			     size * 8 : 0);
 }
 EXPORT_SYMBOL_GPL(add_bootloader_randomness);
 
-- 
2.32.0

From 5d00fe359c1e39f01f44f4c3546625c6445fab7a Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Tue, 1 Jun 2021 07:38:18 +0200
Subject: [PATCH 10/20] LRNG: RNDADDTOENTCNT - entropy estmate update of aux
 pool

The IOCTLs only affect the auxiliary pool. Thus, the entropy update can
only apply to the aux pool as well.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_interfaces.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/char/lrng/lrng_interfaces.c b/drivers/char/lrng/lrng_interfaces.c
index 7102efa..62a0add 100644
--- a/drivers/char/lrng/lrng_interfaces.c
+++ b/drivers/char/lrng/lrng_interfaces.c
@@ -552,7 +552,7 @@ static long lrng_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 			return -EPERM;
 		if (get_user(ent_count_bits, p))
 			return -EFAULT;
-		ent_count_bits = (int)lrng_avail_entropy() + ent_count_bits;
+		ent_count_bits = (int)lrng_avail_aux_entropy() + ent_count_bits;
 		if (ent_count_bits < 0)
 			ent_count_bits = 0;
 		digestsize_bits = lrng_get_digestsize();
-- 
2.32.0

From b9f628510503aac438585b3e022fc9107e6cc9c0 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Tue, 1 Jun 2021 07:39:57 +0200
Subject: [PATCH 11/20] LRNG: cleanup of initial seeding

Due to treating all entropy sources equal, the interrupt entropy source
should not play a special role in the seeding strategy, i.e. when the
DRNG seeding operation is performed during boot.

Thus, the interrupt entropy source now only exports an API that reports
its entropy level. The seeding threshold at which the DRNG is seeded is
given now with the requested amount of entropy in bits rather than in
interrupts. Every time new entropy arrives, the LRNG checks the entropy
level of all entropy sources and decides whether to seed.

This overall change simplifies the code significantly.

This allows the following changes:

* When an entropy source thinks new entropy arrived during boot, it only
  needs to "ping" the LRNG with lrng_pool_add_entropy() - this call is
  added to all entropy sources replacing the previous logic to
  manipulate the seeding threshold.

* Move the scheduler initialization from lrng_drngs_init_cc20 to
  rand_initialize as only with this call the scheduler infrastructure is
  guaranteed to be available.

* The oversampling factors are calculated at the time the entropy
  sources shall return their entropy rate. This means that the seeding
  threshold does not need to be modified to account for this
  oversampling strategy.

* Replacement of lrng_slow_noise_req_entropy with lrng_avail_entropy

* Add lrng_compress_osr as a helper to return the required oversampling
  rate.

* Add lrng_reduce_by_osr as a helper to reduce the entropy source's
  entropy reporting by the oversampling rate.

* Move of lrng_irq_info entirely to lrng_sw_noise.c including the
  service helper functions. With this change, the interrupt entropy
  source is completely self-sufficient like all other sources. This
  implies that soem status flags applicable to the LRNG and not just
  to the interrupt entrop source are moved to lrng_state

* Remove now unneeded lrng_update_entropy_thresh.

* Replace of lrng_pcpu_avail_irqs with lrng_pcpu_avail_entropy to
  report the interrupt entropy source entropy level

* Move struct lrng_pool from the header file to lrng_pool.c as this is
  now completely private.

* Move lrng_pool_configure and lrng_init_time_source to
  lrng_sw_noise.c as it only applies to the interrupt entropy source

* Move the entropy configuration of irq_entropy to lrng_sw_noise.c which
  implies that the external configuration flag is now accessed via
  lrng_sw_pool.irq_entropy

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_archrandom.c |   9 +--
 lrng_drng.c       |   8 +-
 lrng_internal.h   |  80 ++++---------------
 lrng_jent.c       |   7 +-
 lrng_pool.c       | 196 +++++++++++++++++-----------------------------
 lrng_sw_noise.c   |  82 ++++++++++++++++---
 6 files changed, 162 insertions(+), 220 deletions(-)

diff --git a/drivers/char/lrng/lrng_archrandom.c b/drivers/char/lrng/lrng_archrandom.c
index 2be4c89..e82f361 100644
--- a/drivers/char/lrng/lrng_archrandom.c
+++ b/drivers/char/lrng/lrng_archrandom.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
 /*
- * LRNG Fast Noise Source: CPU-based noise source
+ * LRNG Fast Entropy Source: CPU-based entropy source
  *
  * Copyright (C) 2016 - 2021, Stephan Mueller <smueller@chronox.de>
  */
@@ -37,12 +37,7 @@ static int __init lrng_parse_trust_cpu(char *arg)
 
 	if (trust_cpu) {
 		archrandom = LRNG_ARCHRANDOM_TRUST_CPU_STRENGTH;
-		/* Set the initial threshold */
-		lrng_set_entropy_thresh(
-			lrng_slow_noise_req_entropy(
-				LRNG_ARCHRANDOM_TRUST_CPU_STRENGTH));
-		/* Check if DRNG can be seeded. */
-		lrng_pool_add_irq();
+		lrng_pool_add_entropy();
 	} else {
 		archrandom = LRNG_ARCHRANDOM_DEFAULT_STRENGTH;
 	}
diff --git a/drivers/char/lrng/lrng_drng.c b/drivers/char/lrng/lrng_drng.c
index c913e9e..cb6acff 100644
--- a/drivers/char/lrng/lrng_drng.c
+++ b/drivers/char/lrng/lrng_drng.c
@@ -99,7 +99,6 @@ void lrng_drngs_init_cc20(bool force_seed)
 
 	lrng_drng_reset(&lrng_drng_init);
 	lrng_cc20_init_state(&chacha20);
-	lrng_state_init_seed_work();
 	lrng_drng_unlock(&lrng_drng_init, &flags);
 
 	lrng_drng_lock(&lrng_drng_atomic, &flags);
@@ -129,8 +128,7 @@ bool lrng_sp80090c_compliant(void)
 
 	/* Entropy source hash must be capable of transporting enough entropy */
 	if (lrng_get_digestsize() <
-	    (LRNG_DRNG_SECURITY_STRENGTH_BITS +
-	     CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS))
+	    (lrng_security_strength() + CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS))
 		return false;
 
 	/* SP800-90C only requested in FIPS mode */
@@ -397,9 +395,7 @@ static void _lrng_reset(struct work_struct *work)
 			lrng_drng_unlock(drng, &flags);
 		}
 	}
-	lrng_set_entropy_thresh(
-		lrng_slow_noise_req_entropy(LRNG_INIT_ENTROPY_BITS +
-					    CONFIG_LRNG_OVERSAMPLE_ES_BITS));
+	lrng_set_entropy_thresh(LRNG_INIT_ENTROPY_BITS);
 
 	lrng_reset_state();
 }
diff --git a/drivers/char/lrng/lrng_internal.h b/drivers/char/lrng/lrng_internal.h
index 7a2c444..f98442d 100644
--- a/drivers/char/lrng/lrng_internal.h
+++ b/drivers/char/lrng/lrng_internal.h
@@ -151,14 +151,6 @@ static inline u32 lrng_fast_noise_entropylevel(u32 ent_bits, u32 requested_bits)
 u32 lrng_get_arch(u8 *outbuf, u32 requested_bits);
 u32 lrng_archrandom_entropylevel(u32 requested_bits);
 
-static inline u32 lrng_slow_noise_req_entropy(u32 requested_bits)
-{
-	u32 ent_bits = lrng_archrandom_entropylevel(requested_bits) +
-		       lrng_jent_entropylevel(requested_bits);
-
-	return (ent_bits > requested_bits) ? 0 : (requested_bits - ent_bits);
-}
-
 /****************************** DRNG processing *******************************/
 
 /* DRNG state handle */
@@ -228,6 +220,18 @@ static __always_inline void lrng_drng_unlock(struct lrng_drng *drng,
 void lrng_reset(void);
 void lrng_drngs_init_cc20(bool force_seed);
 bool lrng_sp80090c_compliant(void);
+
+static inline u32 lrng_compress_osr(void)
+{
+	return lrng_sp80090c_compliant() ?  CONFIG_LRNG_OVERSAMPLE_ES_BITS : 0;
+}
+
+static inline u32 lrng_reduce_by_osr(u32 entropy_bits)
+{
+	u32 osr_bits = lrng_compress_osr();
+	return (entropy_bits >= osr_bits) ? (entropy_bits - osr_bits) : 0;
+}
+
 bool lrng_get_available(void);
 void lrng_set_available(void);
 void lrng_drng_reset(struct lrng_drng *drng);
@@ -251,44 +255,6 @@ enum lrng_external_noise_source {
 	lrng_noise_source_user
 };
 
-/* Status information about IRQ noise source */
-struct lrng_irq_info {
-	atomic_t num_events_thresh;	/* Reseed threshold */
-	atomic_t reseed_in_progress;	/* Flag for on executing reseed */
-	bool irq_highres_timer;	/* Is high-resolution timer available? */
-	u32 irq_entropy_bits;	/* LRNG_IRQ_ENTROPY_BITS? */
-};
-
-/*
- * This is the entropy pool used by the slow noise source. Its size should
- * be at least as large as LRNG_DRNG_SECURITY_STRENGTH_BITS.
- *
- * The aux pool array is aligned to 8 bytes to comfort the kernel crypto API
- * cipher implementations of the hash functions used to read the pool: for some
- * accelerated implementations, we need an alignment to avoid a realignment
- * which involves memcpy(). The alignment to 8 bytes should satisfy all crypto
- * implementations.
- */
-struct lrng_pool {
-	/*
-	 * Storage for aux data - hash output buffer
-	 */
-	u8 aux_pool[LRNG_MAX_DIGESTSIZE];
-	atomic_t aux_entropy_bits;
-	/* All NUMA DRNGs seeded? */
-	bool all_online_numa_node_seeded;
-
-	/* Digest size of used hash */
-	atomic_t digestsize;
-	/* IRQ noise source status info */
-	struct lrng_irq_info irq_info;
-
-	/* Serialize read of entropy pool and update of aux pool */
-	spinlock_t lock;
-};
-
-u32 lrng_entropy_to_data(u32 entropy_bits);
-u32 lrng_data_to_entropy(u32 irqnum);
 u32 lrng_avail_aux_entropy(void);
 void lrng_set_digestsize(u32 digestsize);
 u32 lrng_get_digestsize(void);
@@ -304,30 +270,17 @@ static inline u32 lrng_security_strength(void)
 	 * size. On the other hand the entropy cannot be larger than the
 	 * security strength of the used DRBG.
 	 */
-	return min_t(u32, LRNG_FULL_SEED_ENTROPY_BITS,
-		     lrng_get_digestsize());
+	return min_t(u32, LRNG_FULL_SEED_ENTROPY_BITS, lrng_get_digestsize());
 }
 
 void lrng_set_entropy_thresh(u32 new);
-void lrng_update_entropy_thresh(u32 new_entropy_bits);
+u32 lrng_avail_entropy(void);
 void lrng_reset_state(void);
 
 bool lrng_pcpu_continuous_compression_state(void);
-void lrng_pcpu_check_compression_state(void);
 void lrng_pcpu_reset(void);
 u32 lrng_pcpu_avail_pool_size(void);
-u32 lrng_pcpu_avail_irqs(void);
-
-static inline u32 lrng_pcpu_avail_entropy(void)
-{
-	return lrng_data_to_entropy(lrng_pcpu_avail_irqs());
-}
-
-static inline u32 lrng_avail_entropy(void)
-{
-	return lrng_pcpu_avail_entropy() + lrng_avail_aux_entropy();
-}
-
+u32 lrng_pcpu_avail_entropy(void);
 int lrng_pcpu_switch_hash(int node,
 			  const struct lrng_crypto_cb *new_cb, void *new_hash,
 			  const struct lrng_crypto_cb *old_cb);
@@ -336,7 +289,6 @@ void lrng_pcpu_array_add_u32(u32 data);
 
 bool lrng_state_exseed_allow(enum lrng_external_noise_source source);
 void lrng_state_exseed_set(enum lrng_external_noise_source source, bool type);
-void lrng_state_init_seed_work(void);
 bool lrng_state_min_seeded(void);
 bool lrng_state_fully_seeded(void);
 bool lrng_state_operational(void);
@@ -347,7 +299,7 @@ void lrng_pool_all_numa_nodes_seeded(void);
 bool lrng_pool_highres_timer(void);
 void lrng_pool_set_entropy(u32 entropy_bits);
 int lrng_pool_insert_aux(const u8 *inbuf, u32 inbuflen, u32 entropy_bits);
-void lrng_pool_add_irq(void);
+void lrng_pool_add_entropy(void);
 
 struct entropy_buf {
 	u8 a[LRNG_DRNG_SECURITY_STRENGTH_BYTES +
diff --git a/drivers/char/lrng/lrng_jent.c b/drivers/char/lrng/lrng_jent.c
index ff07d22..e39d121 100644
--- a/drivers/char/lrng/lrng_jent.c
+++ b/drivers/char/lrng/lrng_jent.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
 /*
- * LRNG Fast Noise Source: Jitter RNG
+ * LRNG Fast Entropy Source: Jitter RNG
  *
  * Copyright (C) 2016 - 2021, Stephan Mueller <smueller@chronox.de>
  */
@@ -28,9 +28,6 @@ static struct rand_data *lrng_jent_state;
 
 static int __init lrng_jent_initialize(void)
 {
-	u32 ent_bits = lrng_fast_noise_entropylevel(jitterrng,
-					LRNG_DRNG_SECURITY_STRENGTH_BITS);
-
 	/* Initialize the Jitter RNG after the clocksources are initialized. */
 	lrng_jent_state = jent_lrng_entropy_collector();
 	if (!lrng_jent_state) {
@@ -39,7 +36,7 @@ static int __init lrng_jent_initialize(void)
 		return 0;
 	}
 	lrng_jent_initialized = true;
-	lrng_update_entropy_thresh(ent_bits);
+	lrng_pool_add_entropy();
 	pr_debug("Jitter RNG working on current system\n");
 
 	return 0;
diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index 2a73f4d..f3c2d84 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
 /*
- * LRNG Entropy pool management
+ * LRNG Entropy sources management
+ * LRNG Slow Entropy Source: Auxiliary entropy pool
  *
  * Copyright (C) 2016 - 2021, Stephan Mueller <smueller@chronox.de>
  */
@@ -21,6 +22,7 @@ struct lrng_state {
 	bool lrng_operational;		/* Is DRNG operational? */
 	bool lrng_fully_seeded;		/* Is DRNG fully seeded? */
 	bool lrng_min_seeded;		/* Is DRNG minimally seeded? */
+	bool all_online_numa_node_seeded;/* All NUMA DRNGs seeded? */
 
 	/*
 	 * To ensure that external entropy providers cannot dominate the
@@ -33,26 +35,40 @@ struct lrng_state {
 	bool lrng_seed_hw;		/* Allow HW to provide seed */
 	bool lrng_seed_user;		/* Allow user space to provide seed */
 
+	atomic_t boot_entropy_thresh;	/* Reseed threshold */
+	atomic_t reseed_in_progress;	/* Flag for on executing reseed */
 	struct work_struct lrng_seed_work;	/* (re)seed work queue */
 };
 
+/*
+ * This is the auxiliary pool
+ *
+ * The aux pool array is aligned to 8 bytes to comfort the kernel crypto API
+ * cipher implementations of the hash functions used to read the pool: for some
+ * accelerated implementations, we need an alignment to avoid a realignment
+ * which involves memcpy(). The alignment to 8 bytes should satisfy all crypto
+ * implementations.
+ */
+struct lrng_pool {
+	u8 aux_pool[LRNG_MAX_DIGESTSIZE];/* Storage for aux data */
+	atomic_t aux_entropy_bits;
+	atomic_t digestsize;		 /* Digest size of used hash */
+
+	/* Serialize read of entropy pool and update of aux pool */
+	spinlock_t lock;
+};
+
 static struct lrng_pool lrng_pool __aligned(LRNG_KCAPI_ALIGN) = {
 	.aux_entropy_bits	= ATOMIC_INIT(0),
 	.digestsize		= ATOMIC_INIT(LRNG_ATOMIC_DIGEST_SIZE),
-	.irq_info		= {
-		.irq_entropy_bits	= LRNG_IRQ_ENTROPY_BITS,
-		.num_events_thresh	= ATOMIC_INIT(LRNG_INIT_ENTROPY_BITS),
-		/* Sample IRQ pointer data at least during boot */
-		.irq_highres_timer	= false },
 	.lock			= __SPIN_LOCK_UNLOCKED(lrng_pool.lock)
 };
 
-static struct lrng_state lrng_state = { false, false, false, true, true };
-
-static u32 irq_entropy __read_mostly = LRNG_IRQ_ENTROPY_BITS;
-module_param(irq_entropy, uint, 0444);
-MODULE_PARM_DESC(irq_entropy,
-		 "How many interrupts must be collected for obtaining 256 bits of entropy\n");
+static struct lrng_state lrng_state = {
+	false, false, false, false, true, true,
+	.boot_entropy_thresh	= ATOMIC_INIT(LRNG_INIT_ENTROPY_BITS),
+	.reseed_in_progress	= ATOMIC_INIT(0),
+};
 
 /********************************** Helper ***********************************/
 
@@ -79,32 +95,15 @@ static inline void lrng_state_exseed_allow_all(void)
 	lrng_state_exseed_set(lrng_noise_source_user, true);
 }
 
-/* Initialize the seed work queue */
-void lrng_state_init_seed_work(void)
-{
-	INIT_WORK(&lrng_state.lrng_seed_work, lrng_drng_seed_work);
-}
-
-/* Convert entropy in bits into number of IRQs with the same entropy content. */
-u32 lrng_entropy_to_data(u32 entropy_bits)
-{
-	return ((entropy_bits * lrng_pool.irq_info.irq_entropy_bits) /
-		LRNG_DRNG_SECURITY_STRENGTH_BITS);
-}
-
-/* Convert number of IRQs into entropy value. */
-u32 lrng_data_to_entropy(u32 irqnum)
-{
-	return ((irqnum * LRNG_DRNG_SECURITY_STRENGTH_BITS) /
-		lrng_pool.irq_info.irq_entropy_bits);
-}
-
 /* Entropy in bits present in aux pool */
 u32 lrng_avail_aux_entropy(void)
 {
 	/* Cap available entropy with max entropy */
-	return min_t(u32, atomic_read_u32(&lrng_pool.digestsize) << 3,
-		     atomic_read_u32(&lrng_pool.aux_entropy_bits));
+	u32 avail_bits = min_t(u32, lrng_get_digestsize(),
+			       atomic_read_u32(&lrng_pool.aux_entropy_bits));
+
+	/* Consider oversampling rate due to aux pool conditioning */
+	return lrng_reduce_by_osr(avail_bits);
 }
 
 /* Set the digest size of the used hash in bytes */
@@ -130,27 +129,6 @@ u32 lrng_get_digestsize(void)
 	return atomic_read_u32(&lrng_pool.digestsize) << 3;
 }
 
-/* Set new entropy threshold for reseeding during boot */
-void lrng_set_entropy_thresh(u32 new_entropy_bits)
-{
-	atomic_set(&lrng_pool.irq_info.num_events_thresh,
-		   lrng_entropy_to_data(new_entropy_bits));
-}
-
-/* Update the seeding threshold new entropy from external sources arrives */
-void lrng_update_entropy_thresh(u32 new_entropy_bits)
-{
-	if (unlikely(!lrng_state_fully_seeded()) && new_entropy_bits) {
-		/* if data arrive before fully seeded, lower trigger point */
-		struct lrng_irq_info *irq_info = &lrng_pool.irq_info;
-		u32 thresh = atomic_read_u32(&irq_info->num_events_thresh);
-		u32 new_irqs = lrng_entropy_to_data(new_entropy_bits);
-
-		thresh = new_irqs > thresh ? 0 : thresh - new_irqs;
-		atomic_set(&irq_info->num_events_thresh, thresh);
-	}
-}
-
 /*
  * Reading of the LRNG pool is only allowed by one caller. The reading is
  * only performed to (re)seed DRNGs. Thus, if this "lock" is already taken,
@@ -159,12 +137,18 @@ void lrng_update_entropy_thresh(u32 new_entropy_bits)
  */
 int lrng_pool_trylock(void)
 {
-	return atomic_cmpxchg(&lrng_pool.irq_info.reseed_in_progress, 0, 1);
+	return atomic_cmpxchg(&lrng_state.reseed_in_progress, 0, 1);
 }
 
 void lrng_pool_unlock(void)
 {
-	atomic_set(&lrng_pool.irq_info.reseed_in_progress, 0);
+	atomic_set(&lrng_state.reseed_in_progress, 0);
+}
+
+/* Set new entropy threshold for reseeding during boot */
+void lrng_set_entropy_thresh(u32 new_entropy_bits)
+{
+	atomic_set(&lrng_state.boot_entropy_thresh, new_entropy_bits);
 }
 
 /*
@@ -178,14 +162,14 @@ void lrng_reset_state(void)
 	lrng_state.lrng_operational = false;
 	lrng_state.lrng_fully_seeded = false;
 	lrng_state.lrng_min_seeded = false;
-	lrng_pool.all_online_numa_node_seeded = false;
+	lrng_state.all_online_numa_node_seeded = false;
 	pr_debug("reset LRNG\n");
 }
 
 /* Set flag that all DRNGs are fully seeded */
 void lrng_pool_all_numa_nodes_seeded(void)
 {
-	lrng_pool.all_online_numa_node_seeded = true;
+	lrng_state.all_online_numa_node_seeded = true;
 }
 
 /* Return boolean whether LRNG reached minimally seed level */
@@ -206,58 +190,22 @@ bool lrng_state_operational(void)
 	return lrng_state.lrng_operational;
 }
 
-/* Return boolean whether LRNG identified presence of high-resolution timer */
-bool lrng_pool_highres_timer(void)
-{
-	return lrng_pool.irq_info.irq_highres_timer;
-}
-
 /* Set entropy content in user-space controllable aux pool */
 void lrng_pool_set_entropy(u32 entropy_bits)
 {
 	atomic_set(&lrng_pool.aux_entropy_bits, entropy_bits);
 }
 
-static void lrng_pool_configure(bool highres_timer, u32 irq_entropy_bits)
+/* Available entropy in the entire LRNG considering all entropy sources */
+u32 lrng_avail_entropy(void)
 {
-	struct lrng_irq_info *irq_info = &lrng_pool.irq_info;
-
-	irq_info->irq_highres_timer = highres_timer;
-	if (irq_info->irq_entropy_bits != irq_entropy_bits) {
-		irq_info->irq_entropy_bits = irq_entropy_bits;
-		/* Reset the threshold based on new oversampling factor. */
-		lrng_set_entropy_thresh(atomic_read_u32(
-						&irq_info->num_events_thresh));
-	}
-}
-
-static int __init lrng_init_time_source(void)
-{
-	/* Set a minimum number of interrupts that must be collected */
-	irq_entropy = max_t(u32, LRNG_IRQ_ENTROPY_BITS, irq_entropy);
-
-	if ((random_get_entropy() & LRNG_DATA_SLOTSIZE_MASK) ||
-	    (random_get_entropy() & LRNG_DATA_SLOTSIZE_MASK)) {
-		/*
-		 * As the highres timer is identified here, previous interrupts
-		 * obtained during boot time are treated like a lowres-timer
-		 * would have been present.
-		 */
-		lrng_pool_configure(true, irq_entropy);
-	} else {
-		lrng_health_disable();
-		lrng_pool_configure(false, irq_entropy *
-					   LRNG_IRQ_OVERSAMPLING_FACTOR);
-		pr_warn("operating without high-resolution timer and applying IRQ oversampling factor %u\n",
-			LRNG_IRQ_OVERSAMPLING_FACTOR);
-		lrng_pcpu_check_compression_state();
-	}
+	u32 ent_thres = atomic_read_u32(&lrng_state.boot_entropy_thresh);
 
-	return 0;
+	return lrng_pcpu_avail_entropy() + lrng_avail_aux_entropy() +
+	       lrng_archrandom_entropylevel(ent_thres) +
+	       lrng_jent_entropylevel(ent_thres);
 }
 
-core_initcall(lrng_init_time_source);
-
 /**
  * lrng_init_ops() - Set seed stages of LRNG
  *
@@ -271,20 +219,21 @@ core_initcall(lrng_init_time_source);
 void lrng_init_ops(struct entropy_buf *eb)
 {
 	struct lrng_state *state = &lrng_state;
-	u32 requested_bits, seed_bits, external_es, osr_bits;
+	u32 requested_bits, seed_bits, external_es;
 
 	if (state->lrng_operational)
 		return;
 
 	requested_bits = lrng_security_strength();
 	if (lrng_sp80090c_compliant())
-		requested_bits = CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS;
+		requested_bits += CONFIG_LRNG_SEED_BUFFER_INIT_ADD_BITS;
 
-	/* Entropy provided by external entropy sources. */
+	/*
+	 * Entropy provided by external entropy sources - if they provide
+	 * the requested amount of entropy, unblock the interface.
+	 */
 	external_es = eb->a_bits + eb->c_bits + eb->d_bits;
 	seed_bits = external_es + eb->b_bits;
-	osr_bits = lrng_sp80090c_compliant() ?
-					CONFIG_LRNG_OVERSAMPLE_ES_BITS : 0;
 
 	/* DRNG is seeded with full security strength */
 	if (state->lrng_fully_seeded) {
@@ -300,7 +249,7 @@ void lrng_init_ops(struct entropy_buf *eb)
 		state->lrng_min_seeded = true;
 		pr_info("LRNG fully seeded with %u bits of entropy\n",
 			seed_bits);
-		lrng_set_entropy_thresh(requested_bits + osr_bits);
+		lrng_set_entropy_thresh(requested_bits);
 		lrng_process_ready_list();
 		lrng_init_wakeup();
 
@@ -312,9 +261,7 @@ void lrng_init_ops(struct entropy_buf *eb)
 			state->lrng_min_seeded = true;
 			pr_info("LRNG minimally seeded with %u bits of entropy\n",
 				seed_bits);
-			lrng_set_entropy_thresh(
-				lrng_slow_noise_req_entropy(
-					lrng_security_strength() + osr_bits));
+			lrng_set_entropy_thresh(requested_bits);
 			lrng_process_ready_list();
 			lrng_init_wakeup();
 
@@ -322,9 +269,7 @@ void lrng_init_ops(struct entropy_buf *eb)
 		} else if (seed_bits >= LRNG_INIT_ENTROPY_BITS) {
 			pr_info("LRNG initial entropy level %u bits of entropy\n",
 				seed_bits);
-			lrng_set_entropy_thresh(
-				lrng_slow_noise_req_entropy(
-					LRNG_MIN_SEED_ENTROPY_BITS + osr_bits));
+			lrng_set_entropy_thresh(LRNG_MIN_SEED_ENTROPY_BITS);
 		}
 	}
 }
@@ -353,6 +298,9 @@ int __init rand_initialize(void)
 	lrng_pool_insert_aux((u8 *)&seed, sizeof(seed), 0);
 	memzero_explicit(&seed, sizeof(seed));
 
+	/* Initialize the seed work queue */
+	INIT_WORK(&lrng_state.lrng_seed_work, lrng_drng_seed_work);
+
 	lrng_drngs_init_cc20(true);
 	invalidate_batched_entropy();
 
@@ -421,19 +369,19 @@ int lrng_pool_insert_aux(const u8 *inbuf, u32 inbuflen, u32 entropy_bits)
 	ret = lrng_pool_insert_aux_locked(inbuf, inbuflen, entropy_bits);
 	spin_unlock_irqrestore(&pool->lock, flags);
 
-	lrng_update_entropy_thresh(entropy_bits);
+	lrng_pool_add_entropy();
 
 	return ret;
 }
 
 /* Hot code path during boot - mix data into entropy pool during boot */
-void lrng_pool_add_irq(void)
+void lrng_pool_add_entropy(void)
 {
 	/*
 	 * Once all DRNGs are fully seeded, the interrupt noise
 	 * sources will not trigger any reseeding any more.
 	 */
-	if (likely(lrng_pool.all_online_numa_node_seeded))
+	if (likely(lrng_state.all_online_numa_node_seeded))
 		return;
 
 	/* Only try to reseed if the DRNG is alive. */
@@ -441,8 +389,8 @@ void lrng_pool_add_irq(void)
 		return;
 
 	/* Only trigger the DRNG reseed if we have collected enough IRQs. */
-	if (lrng_pcpu_avail_irqs() <
-	    atomic_read_u32(&lrng_pool.irq_info.num_events_thresh))
+	if (lrng_avail_entropy() <
+	    atomic_read_u32(&lrng_state.boot_entropy_thresh))
 		return;
 
 	/* Ensure that the seeding only occurs once at any given time. */
@@ -464,9 +412,7 @@ void lrng_pool_add_irq(void)
 static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 {
 	struct lrng_pool *pool = &lrng_pool;
-	u32 collected_ent_bits, returned_ent_bits, unused_bits = 0,
-	    osr_bits = lrng_sp80090c_compliant() ?
-					CONFIG_LRNG_OVERSAMPLE_ES_BITS : 0;
+	u32 collected_ent_bits, returned_ent_bits, unused_bits = 0;
 
 	/* Ensure that no more than the size of aux_pool can be requested */
 	requested_bits = min_t(u32, requested_bits, (LRNG_MAX_DIGESTSIZE << 3));
@@ -476,7 +422,7 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 			       atomic_xchg_relaxed(&pool->aux_entropy_bits, 0));
 
 	/* We collected too much entropy and put the overflow back */
-	if (collected_ent_bits > (requested_bits + osr_bits)) {
+	if (collected_ent_bits > (requested_bits + lrng_compress_osr())) {
 		/* Amount of bits we collected too much */
 		unused_bits = collected_ent_bits - requested_bits;
 		/* Put entropy back */
@@ -486,8 +432,7 @@ static inline u32 lrng_get_aux_pool(u8 *outbuf, u32 requested_bits)
 	}
 
 	/* Apply oversampling: discount requested oversampling rate */
-	returned_ent_bits = (collected_ent_bits >= osr_bits) ?
-					(collected_ent_bits - osr_bits) : 0;
+	returned_ent_bits = lrng_reduce_by_osr(collected_ent_bits);
 
 	pr_debug("obtained %u bits by collecting %u bits of entropy from aux pool, %u bits of entropy remaining\n",
 		 returned_ent_bits, collected_ent_bits, unused_bits);
@@ -515,8 +460,7 @@ void lrng_fill_seed_buffer(struct entropy_buf *entropy_buf, u32 requested_bits)
 
 	/* Require at least 128 bits of entropy for any reseed. */
 	if (state->lrng_fully_seeded &&
-	    (lrng_avail_entropy() <
-	     lrng_slow_noise_req_entropy(LRNG_MIN_SEED_ENTROPY_BITS)))
+	    (lrng_avail_entropy() < LRNG_MIN_SEED_ENTROPY_BITS))
 		goto wakeup;
 
 	/* Ensure aux pool extraction and backtracking op are atomic */
diff --git a/drivers/char/lrng/lrng_sw_noise.c b/drivers/char/lrng/lrng_sw_noise.c
index 10f802b..39d8cbb 100644
--- a/drivers/char/lrng/lrng_sw_noise.c
+++ b/drivers/char/lrng/lrng_sw_noise.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
 /*
- * LRNG Slow Noise Source: Interrupt data collection and random data generation
+ * LRNG Slow Entropy Source: Interrupt data collection
  *
  * Copyright (C) 2016 - 2021, Stephan Mueller <smueller@chronox.de>
  */
@@ -16,6 +16,16 @@
 #include "lrng_internal.h"
 #include "lrng_sw_noise.h"
 
+/* Number of interrupts required for LRNG_DRNG_SECURITY_STRENGTH_BITS entropy */
+static u32 lrng_irq_entropy_bits = LRNG_IRQ_ENTROPY_BITS;
+/* Is high-resolution timer present? */
+static bool lrng_irq_highres_timer = false;
+
+static u32 irq_entropy __read_mostly = LRNG_IRQ_ENTROPY_BITS;
+module_param(irq_entropy, uint, 0444);
+MODULE_PARM_DESC(irq_entropy,
+		 "How many interrupts must be collected for obtaining 256 bits of entropy\n");
+
 /* Per-CPU array holding concatenated entropy events */
 static DEFINE_PER_CPU(u32 [LRNG_DATA_ARRAY_SIZE], lrng_pcpu_array)
 						__aligned(LRNG_KCAPI_ALIGN);
@@ -75,6 +85,26 @@ static DEFINE_PER_CPU(u8 [LRNG_PCPU_POOL_SIZE], lrng_pcpu_pool)
 static DEFINE_PER_CPU(spinlock_t, lrng_pcpu_lock);
 static DEFINE_PER_CPU(bool, lrng_pcpu_lock_init) = false;
 
+/* Return boolean whether LRNG identified presence of high-resolution timer */
+bool lrng_pool_highres_timer(void)
+{
+	return lrng_irq_highres_timer;
+}
+
+/* Convert entropy in bits into number of IRQs with the same entropy content. */
+static inline u32 lrng_entropy_to_data(u32 entropy_bits)
+{
+	return ((entropy_bits * lrng_irq_entropy_bits) /
+		LRNG_DRNG_SECURITY_STRENGTH_BITS);
+}
+
+/* Convert number of IRQs into entropy value. */
+static inline u32 lrng_data_to_entropy(u32 irqnum)
+{
+	return ((irqnum * LRNG_DRNG_SECURITY_STRENGTH_BITS) /
+		lrng_irq_entropy_bits);
+}
+
 static inline bool lrng_pcpu_pool_online(int cpu)
 {
 	return per_cpu(lrng_pcpu_lock_init, cpu);
@@ -85,19 +115,47 @@ bool lrng_pcpu_continuous_compression_state(void)
 	return lrng_pcpu_continuous_compression;
 }
 
-void lrng_pcpu_check_compression_state(void)
+static void lrng_pcpu_check_compression_state(void)
 {
 	/* One pool must hold sufficient entropy for disabled compression */
 	if (!lrng_pcpu_continuous_compression) {
 		u32 max_ent = min_t(u32, lrng_get_digestsize(),
 				    lrng_data_to_entropy(LRNG_DATA_NUM_VALUES));
-		if (max_ent < LRNG_DRNG_SECURITY_STRENGTH_BITS) {
+		if (max_ent < lrng_security_strength()) {
 			pr_warn("Force continuous compression operation to ensure LRNG can hold enough entropy\n");
 			lrng_pcpu_continuous_compression = true;
 		}
 	}
 }
 
+static int __init lrng_init_time_source(void)
+{
+	/* Set a minimum number of interrupts that must be collected */
+	irq_entropy = max_t(u32, LRNG_IRQ_ENTROPY_BITS, irq_entropy);
+
+	if ((random_get_entropy() & LRNG_DATA_SLOTSIZE_MASK) ||
+	    (random_get_entropy() & LRNG_DATA_SLOTSIZE_MASK)) {
+		/*
+		 * As the highres timer is identified here, previous interrupts
+		 * obtained during boot time are treated like a lowres-timer
+		 * would have been present.
+		 */
+		lrng_irq_highres_timer = true;
+		lrng_irq_entropy_bits = irq_entropy;
+	} else {
+		lrng_health_disable();
+		lrng_irq_highres_timer = false;
+		lrng_irq_entropy_bits = irq_entropy *
+					LRNG_IRQ_OVERSAMPLING_FACTOR;
+		pr_warn("operating without high-resolution timer and applying IRQ oversampling factor %u\n",
+			LRNG_IRQ_OVERSAMPLING_FACTOR);
+		lrng_pcpu_check_compression_state();
+	}
+
+	return 0;
+}
+core_initcall(lrng_init_time_source);
+
 /*
  * Reset all per-CPU pools - reset entropy estimator but leave the pool data
  * that may or may not have entropy unchanged.
@@ -126,8 +184,8 @@ u32 lrng_pcpu_avail_pool_size(void)
 	return max_size;
 }
 
-/* Return number of unused IRQs present in all per-CPU pools. */
-u32 lrng_pcpu_avail_irqs(void)
+/* Return entropy of unused IRQs present in all per-CPU pools. */
+u32 lrng_pcpu_avail_entropy(void)
 {
 	u32 digestsize_irqs, irq = 0;
 	int cpu;
@@ -148,7 +206,8 @@ u32 lrng_pcpu_avail_irqs(void)
 							 cpu)));
 	}
 
-	return irq;
+	/* Consider oversampling rate */
+	return  lrng_reduce_by_osr(lrng_data_to_entropy(irq));
 }
 
 /**
@@ -302,8 +361,7 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 	u8 digest[LRNG_MAX_DIGESTSIZE];
 	unsigned long flags, flags2;
 	u32 found_irqs, collected_irqs = 0, collected_ent_bits, requested_irqs,
-	    returned_ent_bits, osr_bits = lrng_sp80090c_compliant() ?
-					     CONFIG_LRNG_OVERSAMPLE_ES_BITS : 0;
+	    returned_ent_bits;
 	int ret, cpu;
 	void *hash;
 
@@ -318,7 +376,8 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 	if (ret)
 		goto err;
 
-	requested_irqs = lrng_entropy_to_data(requested_bits) + osr_bits;
+	requested_irqs = lrng_entropy_to_data(requested_bits) +
+			 lrng_compress_osr();
 
 	/*
 	 * Harvest entropy from each per-CPU hash state - even though we may
@@ -374,8 +433,7 @@ u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded)
 	collected_ent_bits = min_t(u32, collected_ent_bits,
 				   crypto_cb->lrng_hash_digestsize(hash) << 3);
 	/* Apply oversampling: discount requested oversampling rate */
-	returned_ent_bits = (collected_ent_bits >= osr_bits) ?
-					(collected_ent_bits - osr_bits) : 0;
+	returned_ent_bits = lrng_reduce_by_osr(collected_ent_bits);
 
 	pr_debug("obtained %u bits by collecting %u bits of entropy from entropy pool noise source\n",
 		 returned_ent_bits, collected_ent_bits);
@@ -486,7 +544,7 @@ static inline void lrng_pcpu_array_to_hash(u32 ptr)
 	} else {
 		lrng_pcpu_array_compress();
 		/* Ping pool handler about received entropy */
-		lrng_pool_add_irq();
+		lrng_pool_add_entropy();
 	}
 }
 
-- 
2.32.0

From 3755f927d399779a2133863cea39aa62518f9206 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Tue, 1 Jun 2021 07:51:36 +0200
Subject: [PATCH 12/20] LRNG: use work queue after initialization only

It is possible that the LRNG is seeded earlier than the work queue
mechanism is available. When this occurs together with the call to
get_random_bytes before the work queue is initialized, the seeding
operation is stuck. Thus, only use the work queue once it is known that
the work queue system is initialized.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_pool.c | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index f3c2d84..02775bf 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -19,6 +19,7 @@
 #include "lrng_sw_noise.h"
 
 struct lrng_state {
+	bool perform_seedwork;		/* Can seed work be performed? */
 	bool lrng_operational;		/* Is DRNG operational? */
 	bool lrng_fully_seeded;		/* Is DRNG fully seeded? */
 	bool lrng_min_seeded;		/* Is DRNG minimally seeded? */
@@ -65,7 +66,7 @@ static struct lrng_pool lrng_pool __aligned(LRNG_KCAPI_ALIGN) = {
 };
 
 static struct lrng_state lrng_state = {
-	false, false, false, false, true, true,
+	false, false, false, false, false, true, true,
 	.boot_entropy_thresh	= ATOMIC_INIT(LRNG_INIT_ENTROPY_BITS),
 	.reseed_in_progress	= ATOMIC_INIT(0),
 };
@@ -300,6 +301,7 @@ int __init rand_initialize(void)
 
 	/* Initialize the seed work queue */
 	INIT_WORK(&lrng_state.lrng_seed_work, lrng_drng_seed_work);
+	lrng_state.perform_seedwork = true;
 
 	lrng_drngs_init_cc20(true);
 	invalidate_batched_entropy();
@@ -398,7 +400,10 @@ void lrng_pool_add_entropy(void)
 		return;
 
 	/* Seed the DRNG with IRQ noise. */
-	schedule_work(&lrng_state.lrng_seed_work);
+	if (lrng_state.perform_seedwork)
+		schedule_work(&lrng_state.lrng_seed_work);
+	else
+		lrng_drng_seed_work(NULL);
 }
 
 /************************* Get data from entropy pool *************************/
-- 
2.32.0

From d184f1d5c26ed9478433194317d701e337e17757 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Tue, 1 Jun 2021 14:29:00 +0200
Subject: [PATCH 13/20] LRNG: add_random_ready_callback ping after full
 initialization

Waiters are only pinged by the callback once the LRNG is fully
initialized. This allows to make the same claims about the LRNG as the
getrandom(2) system call or /dev/random.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_interfaces.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/drivers/char/lrng/lrng_interfaces.c b/drivers/char/lrng/lrng_interfaces.c
index 62a0add..fbaddac 100644
--- a/drivers/char/lrng/lrng_interfaces.c
+++ b/drivers/char/lrng/lrng_interfaces.c
@@ -62,7 +62,7 @@ void lrng_init_wakeup(void)
 
 /**
  * lrng_process_ready_list() - Ping all kernel internal callers waiting until
- * the DRNG is at least minimally seeded to inform that the DRNG reached that
+ * the DRNG is completely initialized to inform that the DRNG reached that
  * seed level.
  *
  * When the SP800-90B testing is enabled, the ping only happens if the SP800-90B
@@ -75,7 +75,7 @@ void lrng_process_ready_list(void)
 	unsigned long flags;
 	struct random_ready_callback *rdy, *tmp;
 
-	if (!lrng_sp80090b_startup_complete())
+	if (!lrng_state_operational())
 		return;
 
 	spin_lock_irqsave(&lrng_ready_list_lock, flags);
@@ -222,7 +222,7 @@ EXPORT_SYMBOL(del_random_ready_callback);
 
 /**
  * add_random_ready_callback() - Add a callback function that will be invoked
- * when the DRNG is mimimally seeded.
+ * when the DRNG is fully initialized and seeded.
  *
  * @rdy: callback definition to be invoked when the LRNG is seeded
  *
@@ -237,7 +237,7 @@ int add_random_ready_callback(struct random_ready_callback *rdy)
 	unsigned long flags;
 	int err = -EALREADY;
 
-	if (likely(lrng_state_min_seeded()))
+	if (likely(lrng_state_operational()))
 		return err;
 
 	owner = rdy->owner;
@@ -245,7 +245,7 @@ int add_random_ready_callback(struct random_ready_callback *rdy)
 		return -ENOENT;
 
 	spin_lock_irqsave(&lrng_ready_list_lock, flags);
-	if (lrng_state_min_seeded())
+	if (lrng_state_operational())
 		goto out;
 
 	owner = NULL;
-- 
2.32.0

From 01e1d882ba967d96d13e8a454aa6c599cf0e645a Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 07:23:02 +0200
Subject: [PATCH 14/20] LRNG: beautify code

The function declarations for the interrupt entropy source are moved to
a separate block to make it clear visibly that they belong to the
interrupt entropy source.

There are no functional changes implied with this change.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_internal.h | 28 +++++++++++++++-------------
 1 file changed, 15 insertions(+), 13 deletions(-)

diff --git a/drivers/char/lrng/lrng_internal.h b/drivers/char/lrng/lrng_internal.h
index f98442d..85b666c 100644
--- a/drivers/char/lrng/lrng_internal.h
+++ b/drivers/char/lrng/lrng_internal.h
@@ -127,7 +127,7 @@ void lrng_process_ready_list(void);
 /* External interface to use of the switchable DRBG inside the kernel */
 void get_random_bytes_full(void *buf, int nbytes);
 
-/************************** Jitter RNG Noise Source ***************************/
+/************************* Jitter RNG Entropy Source **************************/
 
 #ifdef CONFIG_LRNG_JENT
 u32 lrng_get_jent(u8 *outbuf, u32 requested_bits);
@@ -137,7 +137,7 @@ static inline u32 lrng_get_jent(u8 *outbuf, u32 requested_bits) { return 0; }
 static inline u32 lrng_jent_entropylevel(u32 requested_bits) { return 0; }
 #endif /* CONFIG_CRYPTO_JITTERENTROPY */
 
-/*************************** CPU-based Noise Source ***************************/
+/************************** CPU-based Entropy Source **************************/
 
 static inline u32 lrng_fast_noise_entropylevel(u32 ent_bits, u32 requested_bits)
 {
@@ -151,6 +151,18 @@ static inline u32 lrng_fast_noise_entropylevel(u32 ent_bits, u32 requested_bits)
 u32 lrng_get_arch(u8 *outbuf, u32 requested_bits);
 u32 lrng_archrandom_entropylevel(u32 requested_bits);
 
+/************************** Interrupt Entropy Source **************************/
+
+bool lrng_pcpu_continuous_compression_state(void);
+void lrng_pcpu_reset(void);
+u32 lrng_pcpu_avail_pool_size(void);
+u32 lrng_pcpu_avail_entropy(void);
+int lrng_pcpu_switch_hash(int node,
+			  const struct lrng_crypto_cb *new_cb, void *new_hash,
+			  const struct lrng_crypto_cb *old_cb);
+u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded);
+void lrng_pcpu_array_add_u32(u32 data);
+
 /****************************** DRNG processing *******************************/
 
 /* DRNG state handle */
@@ -248,7 +260,7 @@ static inline struct lrng_drng **lrng_drng_instances(void) { return NULL; }
 static inline void lrng_drngs_numa_alloc(void) { return; }
 #endif /* CONFIG_NUMA */
 
-/************************** Entropy pool management ***************************/
+/************************* Entropy sources management *************************/
 
 enum lrng_external_noise_source {
 	lrng_noise_source_hw,
@@ -277,16 +289,6 @@ void lrng_set_entropy_thresh(u32 new);
 u32 lrng_avail_entropy(void);
 void lrng_reset_state(void);
 
-bool lrng_pcpu_continuous_compression_state(void);
-void lrng_pcpu_reset(void);
-u32 lrng_pcpu_avail_pool_size(void);
-u32 lrng_pcpu_avail_entropy(void);
-int lrng_pcpu_switch_hash(int node,
-			  const struct lrng_crypto_cb *new_cb, void *new_hash,
-			  const struct lrng_crypto_cb *old_cb);
-u32 lrng_pcpu_pool_hash(u8 *outbuf, u32 requested_bits, bool fully_seeded);
-void lrng_pcpu_array_add_u32(u32 data);
-
 bool lrng_state_exseed_allow(enum lrng_external_noise_source source);
 void lrng_state_exseed_set(enum lrng_external_noise_source source, bool type);
 bool lrng_state_min_seeded(void);
-- 
2.32.0

From 6d97df2c2fa2a8ee3961845c572a38ba5621cdc5 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 07:24:51 +0200
Subject: [PATCH 15/20] LRNG: zeroize seed buffer

Immediately after using the seed buffer, it is cleared. This is applied
since the seed buffer holds sensitive data.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_switch.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/char/lrng/lrng_switch.c b/drivers/char/lrng/lrng_switch.c
index c3868b7..c1e3af9 100644
--- a/drivers/char/lrng/lrng_switch.c
+++ b/drivers/char/lrng/lrng_switch.c
@@ -65,6 +65,7 @@ static int lrng_drng_switch(struct lrng_drng *drng_store,
 	} else {
 		/* seed new DRNG with data */
 		ret = cb->lrng_drng_seed_helper(new_drng, seed, ret);
+		memzero_explicit(seed, sizeof(seed));
 		if (ret < 0) {
 			reset_drng = true;
 			pr_warn("seeding of new DRNG failed for NUMA node %d (%d)\n",
-- 
2.32.0

From 75581b2c2ee401ce5ddec51873be96937c7c5550 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 07:26:16 +0200
Subject: [PATCH 16/20] LRNG: invoke processing of ready_list only if fully
 seeded

Since the read_list is only processed once the LRNG is fully
initialized, the trigger call to perform this processing can be limited
to those seed stages.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_pool.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index 02775bf..992e45d 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -263,7 +263,6 @@ void lrng_init_ops(struct entropy_buf *eb)
 			pr_info("LRNG minimally seeded with %u bits of entropy\n",
 				seed_bits);
 			lrng_set_entropy_thresh(requested_bits);
-			lrng_process_ready_list();
 			lrng_init_wakeup();
 
 		/* DRNG is seeded with at least LRNG_INIT_ENTROPY_BITS bits */
-- 
2.32.0

From 8025a4ede7c509caa0512d81313ee1dbe8e0043f Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 07:29:05 +0200
Subject: [PATCH 17/20] LRNG: invoke invalidate_batched_entropy after
 initialization

During very early boot, the CPU masks may not yet be set up properly.
Thus, the code to iterate over present CPUs may not yet be called. Such
code is used in invalidate_batched_entropy. Therefore, ensure that this
code is only called once the LRNG is triggered by the kernel that the
subsystem is available.

Signed-off-by: Alexander Lobakin <alobakin@mailbox.org>
Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_pool.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index 992e45d..beee152 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -19,6 +19,7 @@
 #include "lrng_sw_noise.h"
 
 struct lrng_state {
+	bool can_invalidate;		/* Can invalidate batched entropy? */
 	bool perform_seedwork;		/* Can seed work be performed? */
 	bool lrng_operational;		/* Is DRNG operational? */
 	bool lrng_fully_seeded;		/* Is DRNG fully seeded? */
@@ -66,7 +67,7 @@ static struct lrng_pool lrng_pool __aligned(LRNG_KCAPI_ALIGN) = {
 };
 
 static struct lrng_state lrng_state = {
-	false, false, false, false, false, true, true,
+	false, false, false, false, false, false, true, true,
 	.boot_entropy_thresh	= ATOMIC_INIT(LRNG_INIT_ENTROPY_BITS),
 	.reseed_in_progress	= ATOMIC_INIT(0),
 };
@@ -243,7 +244,9 @@ void lrng_init_ops(struct entropy_buf *eb)
 		lrng_process_ready_list();
 		lrng_init_wakeup();
 	} else if (seed_bits >= requested_bits) {
-		invalidate_batched_entropy();
+		if (state->can_invalidate)
+			invalidate_batched_entropy();
+
 		state->lrng_fully_seeded = true;
 		state->lrng_operational = lrng_sp80090b_startup_complete();
 		state->lrng_operational |= (requested_bits <= external_es);
@@ -258,7 +261,9 @@ void lrng_init_ops(struct entropy_buf *eb)
 
 		/* DRNG is seeded with at least 128 bits of entropy */
 		if (seed_bits >= LRNG_MIN_SEED_ENTROPY_BITS) {
-			invalidate_batched_entropy();
+			if (state->can_invalidate)
+				invalidate_batched_entropy();
+
 			state->lrng_min_seeded = true;
 			pr_info("LRNG minimally seeded with %u bits of entropy\n",
 				seed_bits);
@@ -305,6 +310,8 @@ int __init rand_initialize(void)
 	lrng_drngs_init_cc20(true);
 	invalidate_batched_entropy();
 
+	lrng_state.can_invalidate = true;
+
 	return 0;
 }
 
-- 
2.32.0

From f913f014c400ab046344c2fca2120ece47d69e74 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 13:09:33 +0200
Subject: [PATCH 18/20] LRNG: always fill in the time stamp into seed buffer

When insufficient entropy is present, the seed buffer is not filled with
any entropy. The caller may use it for seeding nonetheless. Therefore,
at least a variating factor should be present. Thus, move the addition
of the time stamp into the seed buffer before the check of the available
entropy.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_pool.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index beee152..acd1485 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -469,6 +469,9 @@ void lrng_fill_seed_buffer(struct entropy_buf *entropy_buf, u32 requested_bits)
 	/* Guarantee that requested bits is a multiple of bytes */
 	BUILD_BUG_ON(LRNG_DRNG_SECURITY_STRENGTH_BITS % 8);
 
+	/* always reseed the DRNG with the current time stamp */
+	entropy_buf->now = random_get_entropy();
+
 	/* Require at least 128 bits of entropy for any reseed. */
 	if (state->lrng_fully_seeded &&
 	    (lrng_avail_entropy() < LRNG_MIN_SEED_ENTROPY_BITS))
@@ -492,9 +495,6 @@ void lrng_fill_seed_buffer(struct entropy_buf *entropy_buf, u32 requested_bits)
 	entropy_buf->c_bits = lrng_get_arch(entropy_buf->c, requested_bits);
 	entropy_buf->d_bits = lrng_get_jent(entropy_buf->d, requested_bits);
 
-	/* also reseed the DRNG with the current time stamp */
-	entropy_buf->now = random_get_entropy();
-
 	/* Mix the extracted data back into pool for backtracking resistance */
 	if (lrng_pool_insert_aux_locked((u8 *)entropy_buf,
 					sizeof(struct entropy_buf), 0))
-- 
2.32.0

From 510a3d1519cb1672720f2bf96ee8a414c472a394 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Wed, 2 Jun 2021 13:12:01 +0200
Subject: [PATCH 19/20] LRNG: initialize entropy value if insufficient entropy
 available

If insufficient entropy is available, the integers transporting the
available entropy are set to zero.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_pool.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index acd1485..fbfc1ee 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -474,8 +474,11 @@ void lrng_fill_seed_buffer(struct entropy_buf *entropy_buf, u32 requested_bits)
 
 	/* Require at least 128 bits of entropy for any reseed. */
 	if (state->lrng_fully_seeded &&
-	    (lrng_avail_entropy() < LRNG_MIN_SEED_ENTROPY_BITS))
+	    (lrng_avail_entropy() < LRNG_MIN_SEED_ENTROPY_BITS)) {
+		entropy_buf->a_bits = entropy_buf->b_bits = 0;
+		entropy_buf->c_bits = entropy_buf->d_bits = 0;
 		goto wakeup;
+	}
 
 	/* Ensure aux pool extraction and backtracking op are atomic */
 	spin_lock_irqsave(&pool->lock, flags);
-- 
2.32.0

From 9a845542f588737dc57e2a481a7c00e427ed3902 Mon Sep 17 00:00:00 2001
From: Stephan Mueller <smueller@chronox.de>
Date: Sun, 6 Jun 2021 16:47:32 +0200
Subject: [PATCH 20/20] LRNG: signal end of boot cycle in non-NUMA
 configuration

The boot cycle is marked to be complete with the flag
all_online_numa_node_seeded. In case of the non-NUMA environment that
was not set and thus an additional but unsuccessful reseed attempt is
tried. This wastes CPU cycles. Therefore, set this flag also in a
non-NUMA setup.

This may imply, however, that NUMA nodes now are a bit later seeded
because the interrupt handler code triggering the pings for new entropy
fires only when the collection pool is full.

Signed-off-by: Stephan Mueller <smueller@chronox.de>
---
 lrng_drng.c     | 7 +++++--
 lrng_internal.h | 2 +-
 lrng_numa.c     | 4 +++-
 lrng_pool.c     | 4 ++--
 4 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/drivers/char/lrng/lrng_drng.c b/drivers/char/lrng/lrng_drng.c
index cb6acff..c9f46a4 100644
--- a/drivers/char/lrng/lrng_drng.c
+++ b/drivers/char/lrng/lrng_drng.c
@@ -263,12 +263,15 @@ void lrng_drng_seed_work(struct work_struct *dummy)
 				goto out;
 			}
 		}
-		lrng_pool_all_numa_nodes_seeded();
 	} else {
-		if (!lrng_drng_init.fully_seeded)
+		if (!lrng_drng_init.fully_seeded) {
 			_lrng_drng_seed_work(&lrng_drng_init, 0);
+			goto out;
+		}
 	}
 
+	lrng_pool_all_numa_nodes_seeded(true);
+
 out:
 	/* Allow the seeding operation to be called again */
 	lrng_pool_unlock();
diff --git a/drivers/char/lrng/lrng_internal.h b/drivers/char/lrng/lrng_internal.h
index 85b666c..e17e537 100644
--- a/drivers/char/lrng/lrng_internal.h
+++ b/drivers/char/lrng/lrng_internal.h
@@ -297,7 +297,7 @@ bool lrng_state_operational(void);
 
 int lrng_pool_trylock(void);
 void lrng_pool_unlock(void);
-void lrng_pool_all_numa_nodes_seeded(void);
+void lrng_pool_all_numa_nodes_seeded(bool set);
 bool lrng_pool_highres_timer(void);
 void lrng_pool_set_entropy(u32 entropy_bits);
 int lrng_pool_insert_aux(const u8 *inbuf, u32 inbuflen, u32 entropy_bits);
diff --git a/drivers/char/lrng/lrng_numa.c b/drivers/char/lrng/lrng_numa.c
index 3781777..fbfb40a 100644
--- a/drivers/char/lrng/lrng_numa.c
+++ b/drivers/char/lrng/lrng_numa.c
@@ -88,8 +88,10 @@ static void _lrng_drngs_numa_alloc(struct work_struct *work)
 	}
 
 	/* counterpart to smp_load_acquire in lrng_drng_instances */
-	if (!cmpxchg_release(&lrng_drng, NULL, drngs))
+	if (!cmpxchg_release(&lrng_drng, NULL, drngs)) {
+		lrng_pool_all_numa_nodes_seeded(false);
 		goto unlock;
+	}
 
 err:
 	for_each_online_node(node) {
diff --git a/drivers/char/lrng/lrng_pool.c b/drivers/char/lrng/lrng_pool.c
index fbfc1ee..f3a432b 100644
--- a/drivers/char/lrng/lrng_pool.c
+++ b/drivers/char/lrng/lrng_pool.c
@@ -169,9 +169,9 @@ void lrng_reset_state(void)
 }
 
 /* Set flag that all DRNGs are fully seeded */
-void lrng_pool_all_numa_nodes_seeded(void)
+void lrng_pool_all_numa_nodes_seeded(bool set)
 {
-	lrng_state.all_online_numa_node_seeded = true;
+	lrng_state.all_online_numa_node_seeded = set;
 }
 
 /* Return boolean whether LRNG reached minimally seed level */
-- 
2.32.0

